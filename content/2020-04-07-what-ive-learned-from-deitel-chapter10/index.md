---
title: نکاتِ جدیدی که از فصل ۱۰ سی++ دایتل یادگرفتم – نکاتی پراکنده
# categories: [سی++]
# tags: [C++, یادگیری, کامپیوتر, برنامه نویسی, سی++]
tags: [cplusplus]
path: blog/what-I-learned-from-deitel-chapter10
cover: ../cplusplus.png
date: 1399-01-19
excerpt: "خلاصه‌ای از مطالب فصل ۱۰ سی++ دایتل"
---

خب فصل ۱۰ ام از کتاب برنامه نویسی سی++ دایتل رو تموم کردم. اینجا خلاصه ای از چیزای جدیدی که یادگرفتم رو می‌نویسم.

## string-object literal

توی سی++ ۱۴ میشه با اضافه کردن یک s به انتهای لیترال رشته‌ای‌مون(بعد 
از دابل کوتیشن، نه قبلش) اون رشته رو تبدیل به یه شئ از کلاس `string` کرد. مثال:

`"Hello, World"s`

## Operator Overloading؛ به عنوان عضو کلاس یا نه؟

با اینکه من قبلا این بخش هارو توی کتاب C How To Program خونده بودم 
اما چون یادداشت نکرده بودم و خیلی وقت هم شده بود که حوصله‌ی برنامه نویسی
رو نداشتم، یادم رفته بود.

مسئله اینه که چه وقتی باید تابع اوپراتوری که overload میشه رو جزئی از
member function ها بذاریم و چه وقتی جزئی از non-member function. 
ساده‌ست، تنها زمانی میتونیم تابع اوپراتور رو به عنوان عضوی از کلاس قرار 
بدیم که شئِ کلاس ما به عنوان پارامتر در سمت چپ قرار بگیره. این کد رو 
ببینید:

```cpp
istream& operator>>(istream& input, MyClass& object);
```

وقتی مینویسیم `cin >> myobject` درواقع انگار تابع رو به شکل `operator>>(input, myobject)` فراخوانی کردیم. 

حالا از اونجایی که شئ ما توی پارامتر سمت چپ قرار نمیگیره، نمیتونیم 
این اوپراتور رو داخل کلاس overload کنیم و اگر اینکارو انجام دادیم، باید 
اینطوری بنویسیمش: `myobject << cin`

از طرف دیگه، برای اینکه بتونیم اوپراتور هامون رو به صورت 
commutative(جابجایی پذیر) تعریف کنیم، به دلایلی که بالاتر توضیح داده شد 
باید حداقل یکبار اوپراتورمون رو به عنوان non-member function تعریف کنیم.

## نکته درباره‌ی Dynamic Allocation در عضو های کلاس

وقتی یک حافظه ای رو به صورت پویا برای یکی از اعضای کلاس‌مون (data-member) در نظر می‌گیریم باید حواسمون باشه که Default
memberwise assignment و Default copy constructor رو به حال خودشون رها 
نکنیم چون مشکلاتی مثل double free رو بوجود میارن. پس یادمون باشه که کپی 
کانستراکتور خودمون + علامت مساوی(=) خودمون رو تعریف کنیم.

## حذف یه تابع از کلاس

یه تابع از کلاس (function member) رو میشه حذف کرد. قبلا برای اینکار، 
اون تابع رو جزء بخش private کلاس قرار می‌دادند اما الان به عنوان مثال 
میشه اینطوری نوشت: 

```cpp
const Array* operator=(const Array*) = delete;
```

کاربردش چیه؟ معمولا برای غیرفعال کردن توابعی که توسط کامپایلر به صورت
خودکار ساخته میشن (auto generate)، مثل سازنده‌ی پیشفرض(Default 
constructor)، کپی کانستراکتور، اوپراتور تخصیص (=) و … استفاده می‌شن.

## تعریف شئ از کلاس با initializer list 

برای اینکه بتونیم یه شئ از کلاسمون رو با initializer list بسازیم، باید یه کانستراکتور داشته باشیم که ورودی‌ش از نوع `initializer_list`باشه. مثال: 

```cpp
MyClass::MyClass(initializer_list list);
```

## تبدیل انواع مختلف به کلاس و بالعکس

ما میتونیم اشیاء ای که از کلاسمون میسازیم رو با استفاده از Conversion
Constructor ها و Conversion Operator ها به انواع دیگه ای تبدیل کنیم. 

برای اینکه یه کانستراکتور تبدیل کننده داشته باشیم نیاز داریم که 
کانستراکتور ما بتونه با یک آرگومان صدا زده بشه.(این مسئله برای کپی 
کانستراکتور ها صادق نیست) مثال : 

```cpp
MyClass::MyClass(int a);
```

حالا با استفاده از این تابع میشه هم به صورت ضمنی و هم به صورت مستقیم یک int رو به شئ ای از کلاس خودمون تبدیل کنیم.

برای تعریف یک Conversion Operator میتونیم اینطوری عمل کنیم:

```cpp
MyClass::operator string() const;
```

حالا اگر فرض کنیم `a` اسم شئ ما باشه، وقتی بنویسیم `static_cast<string> (a) ` درواقع کامپایلر تابع `a.operator string()` رو صدا میزنه.

## چرا توابع سازنده‌مون رو به شکل `explicit` تعریف کنیم؟

توابع سازنده ای که میتونن فقط با یک آرگومان صدا زده بشن ممکنه توسط 
کامپایلر اشتباها به عنوان Conversion Constructor تلقی بشن(چون این تابع 
ها هم با یک ورودی صدا زده میشن) و به صورت ضمنی عمل cast رو انجام بدن. 
درکل ما برای اینکه از تبدیل ضمنی چه توی کانستراکتور(اونایی که میتونن با 
یه آرگومان صدا زده بشن) و چه توی اوپراتور های تبدیلی( conversion 
operator) جلوگیری کنیم، اون توابع رو به صورت explicit تعریف می‌کنیم.

فصل بعدی درباره‌ی ارث‌بری هست 
