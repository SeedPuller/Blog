---
title: نکات جدیدی که از فصل ۱۱ سی++ دایتل یاد گرفتم – ارث بری
# categories: [سی++]
# tags: [C++, inheritance, object oriented, programming, یادگیری, ارث بری, برنامه نویسی, دایتل, سی++, شئ گرایی]
tags: [cplusplus]
path: blog/what-I-learned-from-deitel-chapter11
cover: ../cplusplus.png
date: 1399-02-01
excerpt: "این فصل از دایتل درباره‌ی ویژگی ارث‌بری توی سی++ بود. نکاتی که برام جدیده رو توی این پست نوشتم."
---


این فصل از دایتل درباره‌ی ویژگی ارث‌بری توی سی++ بود. نکاتی که برام جدیده رو توی این پست نوشتم.

## تفاوت is-a relationship و has-a relationship

وقتی یک کلاسی(A) از یک کلاس دیگه(B) ارث بری می‌کنه، میگیم که رابطه‌شون از نوع _is-a relationship_
هست. یعنی کلاس A نوعی از کلاس B عه؛ مثالش؟ «خودرو» و «وسیله نقلیه». 
خودرو از وسیله‌ی نقلیه مشتق شده(نمیدونم این تعبیرِ مشتق شدن درسته یا نه)
و تمام ویژگی های یک وسیله‌ی نقلیه رو داره. درواقع، «خودرو یک وسیله‌ی 
نقلیه‌ست».

اما وقتی یک کلاس در data-member های خود یک شئ از یک کلاس دیگه رو داره(composition) میگیم رابطه‌شون                _has-a relationship_ هست. توی مثال خودرو، میشه فرمون خودرو رو مثال زد که خودش یک شئ هست و عضوی از خودرو محسوب میشه(نه نوعی از خودرو!).

## Constructor

در حالت عادی، توابع سازنده(constructor)، نابودکننده(destructor) و اوپراتور تخصیص (`operator=` ) از کلاس والد ارث برده نمیشن.

وقتی یک شئ از کلاس فرزند(B) ساخته میشه اگه کلاس والد(A) دارای default
constructor باشه، بدون اینکه کانستراکتور والد رو صراحتا صدا بزنیم، خودش
به صورت ضمنی اجرا میشه. اما اگه کلاس A دارای default constructor نباشه 
باید حتما خودمون کانستراکتور کلاس A رو توی کانستراکتور کلاس B صدا بزنیم.

## دسترسی به عناصر `private` والد

کلاس فرزند نمیتونه به طور مستقیم به عناصر `private` کلاس والد دسترسی داشته باشه. برای اینکه بشه اینکار رو انجام داد، اون عناصر مورد نظر توی کلاس والد باید به عنوان `protected` تعریف شده باشن یا اینکه کلاس فرزند از طریق توابع public کلاس والد اقدام به دسترسی گرفتن به عناصر پرایوت بکنه. 

با استفاده از _protected access specifier_ به دلیل اینکه میتونید به صورت مستقیم به عناصر مورد دسترسی داشته باشید، برنامه‌تون کمی سریعتر میشه. در مقابل استفاده از توابع `public` باعث میشه برنامه‌تون کمی کند تر باشه.

اما این روش(`protected`) مشکلاتی هم داره:

اول اینکه ممکنه داده های invalid بهشون تخصیص داده بشه. یعنی از 
اونجایی که دسترسی به صورت مستقیم و بدون اعتبارسنجی به اون‌ها وجود داره، 
ممکنه یک داده‌ی اشتباهی بهشون تخصیص داده بشه.

دوم اینکه برنامه رو شکننده (اصطلاحا _fragile_) میکنه. یعنی کلاس فرزند جای اینکه بر پایه خدماتی(_service_) باشه که کلاس والد ارائه میده، بر پایه‌ی پیاده سازی (_implementation_)
کلاس والد توسعه پیدا میکنه. مشکلش چیه؟ از نظر مهندسی نرم افزار بهتره که
تغییرات رو localize بکنیم. یعنی برنامه طوری نباشه که اگر اسم یکی از 
عناصر رو توی کلاس والد تغییر دادیم، مجبور بشیم تمام جاهایی از کلاس 
فرزندمون که به اون عضو رفرنس دادیم رو تغییر بدیم و استفاده از protected 
پتانسیل بوجود اومدن چنین مشکلی رو ایجاد می‌کنه.

### مگه نگفتی استفاده از توابع public برنامه رو کندتر می‌کنه؟

چرا. اما بهتره که ما اصول مهندسی نرم افزار رو رعایت کنیم و بهینه کردن
کد(optimization) توی این مورد رو به دست کامپایلر بسپاریم. چون خیلی وقتا
کامپایلر خودش بهینه سازی های خوبی انجام میده(مثلا ممکنه توابع set و get
رو به حالت inline دربیاره). به قول معروف، _Do not second-guess the compiler_ .

## فرق بین ارث بری public و بقیه

خود کتاب یه جدول خیلی خوب رسم کرده که من عکسش رو میذارم. به نظرم خوندن همون کافیه ![](https://seedpuller.space/wp-content/uploads/2020/04/image-1.png)

![](https://seedpuller.space/wp-content/uploads/2020/04/image-2.png)

## ارث بردن constructor

بالاتر گفتم که در حالت عادی کانستراکتور از کلاس والد به ارث برده 
نمیشه. اما توی C++ 11 ویژگی ای اضافه شده که اجازه میده کانستراکتور والد 
توسط کلاس فرزند به ارث برده بشه.

برای اینکار باید یه همچین چیزی توی تعریف کلاستون بنویسید:

```cpp
using BaseClass::BaseClass;
```

که `BaseClass` اسم کلاس والد هست. با اینکار، کامپایلر به 
ازای کانستراکتور های موجود توی کلاس والد، یه کانستراکتور توی کلاس فرزند 
میسازه که به طور خودکار تابع متناظرش توی کلاس والد رو صدا بزنه و 
data-member های کلاس فرزند رو default initialize بکنه.

چندتا نکته برای این کار وجود داره:

+ کانستراکتور های default, copy, move ارث بری نمیشن.
+ اگر 
	توی کلاس فرزند کانستراکتوری باشه که ورودی هاش با ورودی های یک 
	کانستراکتور توی کلاس والد یکسان باشه، اون کانستراکتور به ارث برده نمیشه.
+ اگه کانستراکتور دارای default argument باشه، به همون صورت به ارث نمیرسه بلکه به صورت چند کانستراکتور overload شده به ارث میرسه.
+ اگه یه کانستراکتور توی کلاس والد حذف بشه، توی کلاس فرزند هم حذف میشه.

## در آخر

فصل بعدی درباره‌ی چند ریختی یا همون polymorphism عه که دانش ابتدایی ما برای برنامه نویسی شئ‌گرا رو کامل میکنه.
