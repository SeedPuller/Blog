---
title: "فصل ۲۲ دایتل: نکات اضافه"
# categories: [سی++]
# tags: [bit field, C++, structure, using, سی++]
tags: [cplusplus]
path: blog/deitel-chapter22-extra-tips
cover: ../cplusplus.png
date: 1399-05-23
excerpt: "یک‌ سری نکات اضافه درباره سی++"
---

توی این فصل درمورد `struct` ها، bit field ها، اوپراتور های بیتی (bitwise) و توابع مربوط به دستکاری رشته های در سی صحبت شده.

البته دو مورد آخر رو من بلد بودم بنابراین توی این پست دربارشون چیزی نمی‌نویسم. راستی، این آخرین فصل کتاب فیزیکیه و یکی دوتا فصل دیگه هستن که باید اینترنتی خریدشون (=

## structure ها

نکته جالب اینکه `struct` ها تقریبا همون کلاس ها هستند و تنها تفاوت‌شون اینه که اعضای یک `struct` بر خلاف کلاس، به صورت پیش‌فرض `public` هست و همچنین نوع ارث بری به صورت پیش‌فرض `public` هست(که در کلاس ها `private` هست).

## `typedef` و `using`

همونطور که از قبل می‌دونستیم، از typedef برای تعریف کردن alias برای انواع داده هامون استفاده می‌کردیم. مثلا:

```cpp
typdef char* string;
```

توی سی++ ۱۱ قابلیتی اضافه شده که میشه اینکار رو با استفاده از using انجام داد و عبارت پایین برابر با همون typedef عمل می‌کنه:

```cpp
using string = char*;
```

## Binary Literals ها

در سی++‌۱۴ میتونیم از Binary Literal ها استفاده بکنیم. 

برای اینکار کافیه که پشت عبارتمون، کاراکتر 0b یا 0B رو قرار بدیم:

```cpp
const unsigned binary{0b1000000'00000000'00000000'00000000};
```

## Bit Field ها

‌سی++‌ این امکان رو به ما میده که تعیین کنیم یک عضو خاص(از نوع `int` یا `enum`) یک کلاس یا یک `struct` چقدر از حافظه رو اشغال بکنه(تعداد بیت ها). به عضوی که این قابلیت براش استفاده شده باشه میگن _Bit Field_.

```cpp
struct BitCard {
unsigned face : 4;
unsigned suit : 2;
unsigned color : 1;
};
```

با توجه به مثال بالا، اندازهٔ حافظه ای(تعداد بیت ها) که میخوایم عضو ما داشته باشه رو با یک «:» جدا می‌کنیم.

اصطلاحا به اندازه ای که تعیین می‌کنیم میگن width of the bit field.

### unnamed bit field

سی++ این امکان رو به ما میده که عضوی تعریف بکنیم که به عنوان padding 
استفاده بشه. این عضو هیچ اسمی نداره و صرفا به تعداد بیت ای که مشخص 
می‌کنیم، حافظه رو رزرو می‌کنه و اون بخش از حافظه قابل استفاده نیست. 

```cpp
struct Example {
unsigned a : 13;
unsigned : 3; // align to next storage-unit boundary
unsigned b : 4;
};
```

توی مثال بالا تعیین کردیم که ۳ بیت از حافظه رزرو بشه. 

این رزرو کردن به یک شکل دیگه هم میتونه نوشته بشه و اون هم اینکه تعداد بیت های unnamed رو برابر با صفر قرار بدیم.

در این حالت خود کامپایلر میاد و هرچقدر که فضا در اون واحد حافظه باقی 
مونده رو رزرو می‌کنه. عضو بعدی ای که تعریف می‌کنیم در یک واحد دیگه قرار 
می‌گیره.

```cpp
struct Example {
unsigned a : 13;
unsigned : 0; // align to next storage-unit boundary
unsigned b : 4;
};
```

### نکات بیت فیلد ها

+ نباید با استفاده از اوپراتور & سعی کنیم که آدرس یک بیت فیلد رو بگیریم.
+ استفاده
	 از بیت فیلد ها باعث میشه که کامپایلر کد کندتری رو تولید بکنه. بخاطر 
	اینکه محاسبه های بیشتری برای پیدا کردن آدرس های حافظه باید انجام بده.

## پایان

خب این فصل هم به پایان رسید و رسما فصل های موجود در کتاب pdf «آموزش 
برنامه نویسی سی++ دایتل» تموم شد. از این به بعد نکات اضافی ای که از 
منابع دیگه یاد میگیرم رو در پست های جدا می‌نویسم. کتاب جالبی بود 
