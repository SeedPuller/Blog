---
title: از فصل نهم کتاب برنامه نویسی سی++ دایتل چی یادگرفتم
# categories: [سی++]
tags: [cplusplus]
path: blog/what-I-learned-from-deitel-chapter9
cover: ../cplusplus.png
date: 1399-01-10
excerpt: "نکاتی درباره نابودگر، composition و سربارگذاری عملگرها"
---

فصل نهم از کتاب _C++ How To Program_ (نگارش ۲۰۱۷) رو تموم کردم و توی این پست نکاتی که از این فصل یادگرفتم(و یادم مونده=) ) رو می‌نویسم.

## تابع نابودگر (Destructor)

علاوه بر ترتیب اجرا شدنش برای اشیاء مختلف که به صورت «از بیرون به داخل» عه، وظیفه‌ی دیستراکتور درواقع Termination housekeeping عه. مثالش میشه کلاس file از _STL_ که قبل از نابود شدن، فایل هایی که باز موندن توسط این تابع بسته میشن.

## ممبر فانکشن های `const`

علاوه بر رعایت Least privilege principle در هنگام نوشتن توابع که موجب میشه تابع هایی که دیتا ممبر های کلاس رو تغییر نمیدن رو به صورت `const` تعریف کنیم، اگر شئ ای رو به صورت `const` توی کدِ کلاینت‌مون تعریف کنیم اونوقت تنها از متود هایی میتونیم استفاده کنیم که قبلا `const` تعریف شدن.

## یک شئ به عنوان عضوی از کلاس (Composition)

نکته‌ی اول اینکه دیتا ممبر های یک کلاس به ترتیب تعریف شدنشون ساخته(کانستراکت) میشن نه به ترتیب نوشتنشون توی member-initializer list (ولی بهتره برای خوانایی کد به همون ترتیبی که تعریف شدن توی لیست شروع کننده هم نوشته بشن). همچنین، دیتا ممبر ها قبل از کانستراکت شدنِ شئ ای که داخلش قرار دارن ساخته میشن. 

> دیتا ممبر ها قبل از کانستراکت شدنِ شئ ای که داخلش قرار دارن ساخته میشن.

برای همینه که مهمه وقتی از Composition استفاده می‌کنیم حتما از member-initializer list استفاده کنیم. اگر اینکار رو انجام ندیم و داخل بدنه‌ی کانستراکتور اشیاء رو بسازیم، درواقع داریم اون ها رو دوباره مقدار دهی میکنیم.

چون یکبار دیفالت کانستراکتور خودشون موقع ساخته شدن شئ اصلی(= Enclosing Object) صدا زده میشه و بعد یکبار هم ما مقدار دهیشون میکنیم.

با استفاده از member-initializer list میتونیم از این دوباره کاری جلوگیری کنیم.

## اشاره گر `this`

یه نکته ای که راجع به این اشاره گر فهمیدم این بود که اگر بر فرض اسم کلاس ما _Test_ باشه، اشاره گر `this` از نوع `const Test*` عه

## فصل بعدیِ کتاب

فصل بعدی درباره‌ی Operator Overloading عه.
