{"expireTime":9007200880603432000,"key":"transformer-remark-markdown-html-e0bfb8f7c942b9a5764d76bbe71c9a61-gatsby-remark-imagesgatsby-remark-audiogatsby-remark-external-linksgatsby-remark-prismjs-","val":"<p><a href=\"https://seedpuller.space/2020/08/26/smart-poitners-unique-ptr/\" target=\"_blank\" rel=\"nofollow\">توی پست قبل</a>\nدرباره اینکه چرا باید از اشاره گر های هوشمند استفاده کنیم حرف زدم و\nکلاس std::unique<em>ptr رو بررسی سطحی کردیم. توی این پست قراره درباره نوع\nدیگه ای از اشاره گر های هوشمند بنویسم که برعکس unique</em>ptr به ما اجازه\nمیده چند شئ بتونن یک حافظه یکسان رو مدیریت کنن.</p>\n<h2>نحوه عملکرد</h2>\n<p>کلاس shared_ptr اینطور عمل می‌کنه که تعداد اشیاء ای که دارن از یک\nحافظه خاص نگهداری می‌کنن رو یادش میمونه و تنها زمانی اون حافظه رو آزاد\nمی‌کنه که آخرین شئ نگهدارنده بخواد از بین بره.</p>\n<p>مثال زیر:</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;iostream></span></span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;memory></span> <span class=\"token comment\">// for std::shared_ptr</span></span>\n  \n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Resource</span>\n<span class=\"token punctuation\">{</span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n    <span class=\"token function\">Resource</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> std<span class=\"token double-colon punctuation\">::</span>cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"Resource acquired\\n\"</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span>\n    <span class=\"token operator\">~</span><span class=\"token function\">Resource</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> std<span class=\"token double-colon punctuation\">::</span>cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"Resource destroyed\\n\"</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  \n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// allocate a Resource object and have it owned by std::shared_ptr</span>\n    Resource <span class=\"token operator\">*</span>res <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> Resource<span class=\"token punctuation\">;</span>\n    std<span class=\"token double-colon punctuation\">::</span>shared_ptr<span class=\"token operator\">&lt;</span>Resource<span class=\"token operator\">></span> <span class=\"token function\">ptr1</span><span class=\"token punctuation\">(</span>res<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">{</span>\n        std<span class=\"token double-colon punctuation\">::</span>shared_ptr<span class=\"token operator\">&lt;</span>Resource<span class=\"token operator\">></span> <span class=\"token function\">ptr2</span><span class=\"token punctuation\">(</span>ptr1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// use copy initialization to make another std::shared_ptr pointing to the same thing</span>\n  \n        std<span class=\"token double-colon punctuation\">::</span>cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"Killing one shared pointer\\n\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token comment\">// ptr2 goes out of scope here, but nothing happens</span>\n  \n    std<span class=\"token double-colon punctuation\">::</span>cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"Killing another shared pointer\\n\"</span><span class=\"token punctuation\">;</span>\n  \n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span> <span class=\"token comment\">// ptr1 goes out of scope here, and the allocated Resource is destroyed</span></code></pre></div>\n<p>که خروجی این کد به شکل زیر هست:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Resource acquired\nKilling one shared pointer\nKilling another shared pointer\nResource destroyed</code></pre></div>\n<p>اگر این یک کلاس unique_ptr بود، کدی که درون بلوک داخلیِ main قرار\nداشت می‌بایست حافظه رو آزاد می‌کرد اما با استفاده از این کلاس دیگه این\nاتفاق نمیوفته.</p>\n<p>یه نکته هست که باید بهش توجه بشه اونم اینکه برای ساختن ptr2 باید ptr1\nرو بهش پاس بدیم تا عمل کپی انجام بگیره. اگر اشتباها res رو بهش بدیم،\nدیگه اون دوتا شئ همدیگه رو نمی‌شناسن و ptr2 میاد حافظه ای که گرفته رو\nحذف می‌کنه.</p>\n<h2>make_shared</h2>\n<p>کلاس shared<em>ptr هم مثل unique</em>ptr یه همراه به اسم make<em>shared داره که\nبهتره بجای گرفتن حافظه به طور دستی و پاس دادنش به کلاس shared</em>ptr، از\nmake_shared استفاده کنیم تا جلوی خیلی از مشکلات هم گرفته بشه(یکیش همون\nنکته ای که بالاتر گفتم).</p>\n<p>نحوه استفاده‌ش هم خیلی ساده‌ست:</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;iostream></span></span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;memory></span> <span class=\"token comment\">// for std::shared_ptr</span></span>\n  \n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Resource</span>\n<span class=\"token punctuation\">{</span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n    <span class=\"token function\">Resource</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> std<span class=\"token double-colon punctuation\">::</span>cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"Resource acquired\\n\"</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span>\n    <span class=\"token operator\">~</span><span class=\"token function\">Resource</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> std<span class=\"token double-colon punctuation\">::</span>cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"Resource destroyed\\n\"</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  \n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// allocate a Resource object and have it owned by std::shared_ptr</span>\n    <span class=\"token keyword\">auto</span> ptr1 <span class=\"token operator\">=</span> std<span class=\"token double-colon punctuation\">::</span><span class=\"token generic-function\"><span class=\"token function\">make_shared</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span>Resource<span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">auto</span> ptr2 <span class=\"token operator\">=</span> ptr1<span class=\"token punctuation\">;</span> <span class=\"token comment\">// create ptr2 using copy initialization of ptr1</span>\n  \n        std<span class=\"token double-colon punctuation\">::</span>cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"Killing one shared pointer\\n\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token comment\">// ptr2 goes out of scope here, but nothing happens</span>\n  \n    std<span class=\"token double-colon punctuation\">::</span>cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"Killing another shared pointer\\n\"</span><span class=\"token punctuation\">;</span>\n  \n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span> <span class=\"token comment\">// ptr1 goes out of scope here, and the allocated Resource is destroyed</span></code></pre></div>\n<p>به همین راحتی (:</p>\n<h2>این کلاس چطور کار می‌کنه؟</h2>\n<p>درواقع نحوه کار این کلاس اینطوری هست که بجز یک اشاره گر که برای حافظه\nای که نگهداری می‌کنه، یک اشاره گر دیگه هم به یک Control Block داره که\nدرواقع اونم یک شئ هست که وظیفه‌ش نگهداری تعداد اشیاء ای هست که دارن به\nحافظه مربوطه اشاره می‌کن.</p>\n<p>برای همینه که برای ساختن یک شئ جدید اگر از عمل کپی کردن استفاده\nنکنیم، دیگه این کلاس کاربرد نداره. برای اینه که وقتی از عمل کپی استفاده\nمی‌کنیم اون control block میفهمه که یک شئ دیگه ای هم در کاره.</p>\n<p>اما وقتی به صورت مستقیم یک حافظه رو در اختیار یک shared_ptr می‌‌ذاریم، میاد و یک control block جدید برای خودش می‌سازه.</p>\n<h2>پایان</h2>\n<p>در آخر چیز خیلی خاصی به ذهنم نمی‌رسه که بخوام بگم (:</p>\n<p>شاید بعدا یه پست درباره weak_ptr و مشکل circular dependency هم نوشتم (:\nراستی، این کلاس هنوز به درسی از آرایه ها پشتیبانی نمی‌کنه و احتمالا این پشتیبانی توی سی++ ۲۰ بهش اضافه میشه.</p>"}