{"expireTime":9007200880603431000,"key":"transformer-remark-markdown-html-eaef53ca0b3d306eecdc2775be4ba16b-gatsby-remark-imagesgatsby-remark-audiogatsby-remark-external-linksgatsby-remark-prismjs-","val":"<p>در این پست درباره اینکه چطور می‌تونیم یک سری ژانگولر بازی با mutex ها دربیاریم صحبت می‌کنیم. مثلا چطور میوتکس ها رو بین scope ها جابجا کنیم، یا چطور با انعطاف بیشتری نسبت به قفل کردن mutex ها اقدام کنیم و چه‌قدر میوتکس هارو قفل نگه‌ داریم و کارهایی از این دست.</p>\n<h2>انعطاف پذیری بیشتر در قفل کردن میوتکس ها</h2>\n<p>با استفاده از <code class=\"language-text\">std::unique_lock</code> دستمون برای</p>\n<ul>\n<li>قفل کردن / آزاد کردن</li>\n<li>مالکیت</li>\n<li>جابجا کردن mutex بین scope ها\nباز است.</li>\n</ul>\n<h3>قفل کردن</h3>\n<p>به عنوان مثال: اگه می‌خواستیم دوتا میوتکس رو همزمان قفل کنیم و برای اینکار از <code class=\"language-text\">std::lock</code> استفاده بکنیم، نیاز داشتیم همچین چیزی بنویسیم:</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\">std<span class=\"token double-colon punctuation\">::</span>mutex m1<span class=\"token punctuation\">;</span>\nstd<span class=\"token double-colon punctuation\">::</span>mutex m2<span class=\"token punctuation\">;</span>\nstd<span class=\"token double-colon punctuation\">::</span><span class=\"token function\">lock</span><span class=\"token punctuation\">(</span>m1<span class=\"token punctuation\">,</span> m2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nstd<span class=\"token double-colon punctuation\">::</span><span class=\"token generic-function\"><span class=\"token function\">lock_guard</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span>std<span class=\"token double-colon punctuation\">::</span>mutex<span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>m1<span class=\"token punctuation\">,</span> std<span class=\"token double-colon punctuation\">::</span>adopt_lock<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nstd<span class=\"token double-colon punctuation\">::</span><span class=\"token generic-function\"><span class=\"token function\">lock_guard</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span>std<span class=\"token double-colon punctuation\">::</span>mutex<span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>m2<span class=\"token punctuation\">,</span> std<span class=\"token double-colon punctuation\">::</span>adopt_lock<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>البته فرض رو بر این گذاشتم که از استاندارد پایین تر از <code class=\"language-text\">C++17</code> داریم استفاده می‌کنیم. همونطور که توی کد بالا می‌بینید، اول قفل‌شون کردیم و سپس برای اینکه مدیریتشون به درستی انجام بشه میوتکس ها رو به یک شئ <code class=\"language-text\">std::lock_guard</code> می‌سپاریم. ولی این کلاس در تابع سازنده(constructor) خودش میاد و میوتکس هارو قفل می‌کنه. برای اینکه بهش بگیم که این میوتکس ها از قبل قفل شده‌ن و صرفا مالکیتشون رو بر عهده بگیره، میایم و از <code class=\"language-text\">std::adopt_lock</code> به عنوان پارامتر دوم استفاده می‌کنیم.</p>\n<p>حالا <code class=\"language-text\">std::unique_lock</code> چیکار می‌کنه؟ میتونیم با استفاده از <code class=\"language-text\">std::defer_lock</code>  بهش بگیم که در زمان ساخت، میوتکس ها رو قفل نکنه. بنابراین کد بالا همچین شکلی میشه:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">std::unique_lock&lt;std::mutex> lock_a(m1,std::defer_lock);\nstd::unique_lock&lt;std::mutex> lock_b(m2,std::defer_lock);\nstd::lock(lock_a,lock_b);</code></pre></div>\n<p>این دو کد یک کار رو انجام می‌دن فقط با این تفاوت که <code class=\"language-text\">std::unique_lock</code> حافظه بیشتری نسبت به <code class=\"language-text\">std::lock_guard</code> مصرف می‌کنه. همچنین میشه اشیاء <code class=\"language-text\">std::unique_lock</code> رو به <code class=\"language-text\">std::lock</code> هم پاس داد و این به این معنیه که این کلاس دارای توابع <code class=\"language-text\">lock</code> و <code class=\"language-text\">unlock</code> و <code class=\"language-text\">try_lock</code> و امثالهم هست و میشه به شکل دستی این توابع رو روی یک شئ <code class=\"language-text\">std::unique_lock</code> اجرا کرد. بهرحال،‌ این کلاس کُند تر از کلاس هایی مثل <code class=\"language-text\">std::lock_guard</code> و <code class=\"language-text\">std::scoped_lock</code> هست و همچنین حافظه بیشتری هم مصرف می‌کنه. پس اگه واقعا به این انعطافش نیاز نداریم، نباید ازش استفاده کنیم.</p>\n<h3>باز کردن</h3>\n<p>کلاس <code class=\"language-text\">std::unique_lock</code> این قابلیت رو داره که بتونیم به شکل دستی میوتکس‌مون رو قفل/آزاد کنیم. بنابراین نیاز نیست که حتما صبر کنیم تا شئ نابود بشه تا mutex آزاد بشه. این قابلیت مهمیه. یعنی می‌تونیم دقیقا بعد از اینکه کار ما با mutex تموم شد سریع آزادش کنیم که وقتی کاری با mutex نداریم، بیخود بقیه ترد هارو منتظر نذاریم.</p>\n<p>یک استفاده دیگهٔ <code class=\"language-text\">std::unique_lock</code> این هست که می‌تونیم مالکیت یک mutex رو بین scope ها جابجا بکنیم.</p>\n<h3>جابجا کردن مالکیت یک میوتکس بین scope ها</h3>\n<p>کلاس <code class=\"language-text\">std::unique_lock</code> یک کلاس جابجایی پذیر یا <em>movable</em> هست. یعنی محتوای شئ x میتونه به شئ y منتقل بشه.\nالبته خوبه که حواسمون باشه این کلاس رونوشت پذیر یا <em>copyable</em>نیست. مثال برای انتقال مالکیت یک mutex بین اشیاء:</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\">std<span class=\"token double-colon punctuation\">::</span>unique_lock<span class=\"token operator\">&lt;</span>std<span class=\"token double-colon punctuation\">::</span>mutex<span class=\"token operator\">></span> <span class=\"token function\">get_lock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">extern</span> std<span class=\"token double-colon punctuation\">::</span>mutex some_mutex<span class=\"token punctuation\">;</span>\n\tstd<span class=\"token double-colon punctuation\">::</span>unique_lock<span class=\"token operator\">&lt;</span>std<span class=\"token double-colon punctuation\">::</span>mutex<span class=\"token operator\">></span> <span class=\"token function\">lk</span><span class=\"token punctuation\">(</span>some_mutex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token function\">prepare_data</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">return</span> lk<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">process_data</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n\tstd<span class=\"token double-colon punctuation\">::</span>unique_lock<span class=\"token operator\">&lt;</span>std<span class=\"token double-colon punctuation\">::</span>mutex<span class=\"token operator\">></span> <span class=\"token function\">lk</span><span class=\"token punctuation\">(</span><span class=\"token function\">get_lock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token function\">do_something</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>در این کد، ابتدا میوتکس در تابع <code class=\"language-text\">get_lock()</code> قفل میشه و سپس به تابع <code class=\"language-text\">process_data()</code> منتقل میشه.</p>\n<h2>به اندازه قفل کن، همیشه قفل کن</h2>\n<p>قبل تر درباره اهمیت قفل کردنِ به اندازهٔ داده ها صحبت کردیم تقریبا. گفتیم اگر زیادی واحد های کوچیک رو قفل کنیم، امکان race condition رو زیاد کردیم و اگر زیادی هم بزرگ قفل کنیم، فایده های همروندی رو از بین بردیم. اما اندازهٔ قفل کردن فقط مربوط به اندازه داده ها نیست بلکه این موضوع که چه مدتی هم قفل رو نگه‌داریم، همون قدر مهمه!</p>\n<p>اگه یک داده بیش از اندازه مورد نیازمون در حالت قفل نگه داریم یعنی عملا بقیه ترد ها باید بیخودی منتظر باشن. پس باید granularity رو به خوبی تنظیم بکنیم؛ هم در اندازه داده و هم در مدت زمان قفل بودن.</p>\n<p>بنابراین باید سعی کنیم که فقط زمانی که نیاز به استفاده از shared data هستیم، داده رو قفل کنیم. مثلا اگر داریم یک کار I/O انجام می‌دیم که استفاده مستقیمی از داده قفل شده نداره، نگه داشتن قفل فقط باعث میشه که بقیه ترد ها بیخودی منتظر بمونن. مخصوصا اگر این  I/O برای یک فایل باشه(چون خواندن/نوشتن فایل ها خیلی کُند صورت می‌گیره).</p>\n<p>یک مثال ببینیم:</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">void</span> <span class=\"token function\">get_and_process_data</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n\tstd<span class=\"token double-colon punctuation\">::</span>unique_lock<span class=\"token operator\">&lt;</span>std<span class=\"token double-colon punctuation\">::</span>mutex<span class=\"token operator\">></span> <span class=\"token function\">my_lock</span><span class=\"token punctuation\">(</span>the_mutex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\tsome_class data_to_process<span class=\"token operator\">=</span><span class=\"token function\">get_next_data_chunk</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\tmy_lock<span class=\"token punctuation\">.</span><span class=\"token function\">unlock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// checkpoint 1</span>\n\tresult_type result<span class=\"token operator\">=</span><span class=\"token function\">process</span><span class=\"token punctuation\">(</span>data_to_process<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\tmy_lock<span class=\"token punctuation\">.</span><span class=\"token function\">lock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// checkpoint 2</span>\n\t<span class=\"token function\">write_result</span><span class=\"token punctuation\">(</span>data_to_process<span class=\"token punctuation\">,</span>result<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>همونطور که در کد بالا مشخصه، اول داده رو خوندیم، برای پردازش بعدی نیازی به نگه داشتن قفل نبود؛ پس میوتکس رو آزاد کردیم(به استفاده از <code class=\"language-text\">std::unique_lock</code> دقت شود). بعدش که دوباره نیاز به استفاده از داده اشتراک گذاری‌شده‌مون داشتیم، میوتکس رو قفل می‌کنیم.</p>\n<p>البته... باید حواسمون به این هم  باشه که:</p>\n<blockquote>\n<p>اگه یک داده رو در تمام زمان انجام عملیات قفل نگه‌ نداری، یعنی یک امکان برای بوجود اومدن Race Condition احتمالی ایجاد کردی که باید حواست بهش جمع باشه.</p>\n</blockquote>\n<h2>پایان</h2>\n<p>در نهایت، میوتکس ها تنها گزینه ما نیستن! خیلی وقت ها اصلا ساختمان داده ما طوری نیست که بشه به راحتی براش granularity در نظر گرفت چراکه بخش های مختلف یک ساختمان داده نیازمند سطوح مختلفی از حفاظت هستن. در پُست بعدی یک‌سری جایگزین های ساده رو برای mutex ها بررسی می‌کنیم.</p>"}