{"expireTime":9007200880603433000,"key":"transformer-remark-markdown-html-6cd7c486e234ff62ce707a1f7878df91-gatsby-remark-imagesgatsby-remark-audiogatsby-remark-external-linksgatsby-remark-prismjs-","val":"<p>این فصل از دایتل درباره‌ی ویژگی ارث‌بری توی سی++ بود. نکاتی که برام جدیده رو توی این پست نوشتم.</p>\n<h2>تفاوت is-a relationship و has-a relationship</h2>\n<p>وقتی یک کلاسی(A) از یک کلاس دیگه(B) ارث بری می‌کنه، میگیم که رابطه‌شون از نوع <em>is-a relationship</em>\nهست. یعنی کلاس A نوعی از کلاس B عه؛ مثالش؟ «خودرو» و «وسیله نقلیه».\nخودرو از وسیله‌ی نقلیه مشتق شده(نمیدونم این تعبیرِ مشتق شدن درسته یا نه)\nو تمام ویژگی های یک وسیله‌ی نقلیه رو داره. درواقع، «خودرو یک وسیله‌ی\nنقلیه‌ست».</p>\n<p>اما وقتی یک کلاس در data-member های خود یک شئ از یک کلاس دیگه رو داره(composition) میگیم رابطه‌شون                <em>has-a relationship</em> هست. توی مثال خودرو، میشه فرمون خودرو رو مثال زد که خودش یک شئ هست و عضوی از خودرو محسوب میشه(نه نوعی از خودرو!).</p>\n<h2>Constructor</h2>\n<p>در حالت عادی، توابع سازنده(constructor)، نابودکننده(destructor) و اوپراتور تخصیص (<code class=\"language-text\">operator=</code> ) از کلاس والد ارث برده نمیشن.</p>\n<p>وقتی یک شئ از کلاس فرزند(B) ساخته میشه اگه کلاس والد(A) دارای default\nconstructor باشه، بدون اینکه کانستراکتور والد رو صراحتا صدا بزنیم، خودش\nبه صورت ضمنی اجرا میشه. اما اگه کلاس A دارای default constructor نباشه\nباید حتما خودمون کانستراکتور کلاس A رو توی کانستراکتور کلاس B صدا بزنیم.</p>\n<h2>دسترسی به عناصر <code class=\"language-text\">private</code> والد</h2>\n<p>کلاس فرزند نمیتونه به طور مستقیم به عناصر <code class=\"language-text\">private</code> کلاس والد دسترسی داشته باشه. برای اینکه بشه اینکار رو انجام داد، اون عناصر مورد نظر توی کلاس والد باید به عنوان <code class=\"language-text\">protected</code> تعریف شده باشن یا اینکه کلاس فرزند از طریق توابع public کلاس والد اقدام به دسترسی گرفتن به عناصر پرایوت بکنه. </p>\n<p>با استفاده از <em>protected access specifier</em> به دلیل اینکه میتونید به صورت مستقیم به عناصر مورد دسترسی داشته باشید، برنامه‌تون کمی سریعتر میشه. در مقابل استفاده از توابع <code class=\"language-text\">public</code> باعث میشه برنامه‌تون کمی کند تر باشه.</p>\n<p>اما این روش(<code class=\"language-text\">protected</code>) مشکلاتی هم داره:</p>\n<p>اول اینکه ممکنه داده های invalid بهشون تخصیص داده بشه. یعنی از\nاونجایی که دسترسی به صورت مستقیم و بدون اعتبارسنجی به اون‌ها وجود داره،\nممکنه یک داده‌ی اشتباهی بهشون تخصیص داده بشه.</p>\n<p>دوم اینکه برنامه رو شکننده (اصطلاحا <em>fragile</em>) میکنه. یعنی کلاس فرزند جای اینکه بر پایه خدماتی(<em>service</em>) باشه که کلاس والد ارائه میده، بر پایه‌ی پیاده سازی (<em>implementation</em>)\nکلاس والد توسعه پیدا میکنه. مشکلش چیه؟ از نظر مهندسی نرم افزار بهتره که\nتغییرات رو localize بکنیم. یعنی برنامه طوری نباشه که اگر اسم یکی از\nعناصر رو توی کلاس والد تغییر دادیم، مجبور بشیم تمام جاهایی از کلاس\nفرزندمون که به اون عضو رفرنس دادیم رو تغییر بدیم و استفاده از protected\nپتانسیل بوجود اومدن چنین مشکلی رو ایجاد می‌کنه.</p>\n<h3>مگه نگفتی استفاده از توابع public برنامه رو کندتر می‌کنه؟</h3>\n<p>چرا. اما بهتره که ما اصول مهندسی نرم افزار رو رعایت کنیم و بهینه کردن\nکد(optimization) توی این مورد رو به دست کامپایلر بسپاریم. چون خیلی وقتا\nکامپایلر خودش بهینه سازی های خوبی انجام میده(مثلا ممکنه توابع set و get\nرو به حالت inline دربیاره). به قول معروف، <em>Do not second-guess the compiler</em> .</p>\n<h2>فرق بین ارث بری public و بقیه</h2>\n<p>خود کتاب یه جدول خیلی خوب رسم کرده که من عکسش رو میذارم. به نظرم خوندن همون کافیه <img src=\"https://seedpuller.space/wp-content/uploads/2020/04/image-1.png\"></p>\n<p><img src=\"https://seedpuller.space/wp-content/uploads/2020/04/image-2.png\"></p>\n<h2>ارث بردن constructor</h2>\n<p>بالاتر گفتم که در حالت عادی کانستراکتور از کلاس والد به ارث برده\nنمیشه. اما توی C++ 11 ویژگی ای اضافه شده که اجازه میده کانستراکتور والد\nتوسط کلاس فرزند به ارث برده بشه.</p>\n<p>برای اینکار باید یه همچین چیزی توی تعریف کلاستون بنویسید:</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">using</span> BaseClass<span class=\"token double-colon punctuation\">::</span>BaseClass<span class=\"token punctuation\">;</span></code></pre></div>\n<p>که <code class=\"language-text\">BaseClass</code> اسم کلاس والد هست. با اینکار، کامپایلر به\nازای کانستراکتور های موجود توی کلاس والد، یه کانستراکتور توی کلاس فرزند\nمیسازه که به طور خودکار تابع متناظرش توی کلاس والد رو صدا بزنه و\ndata-member های کلاس فرزند رو default initialize بکنه.</p>\n<p>چندتا نکته برای این کار وجود داره:</p>\n<ul>\n<li>کانستراکتور های default, copy, move ارث بری نمیشن.</li>\n<li>اگر\nتوی کلاس فرزند کانستراکتوری باشه که ورودی هاش با ورودی های یک\nکانستراکتور توی کلاس والد یکسان باشه، اون کانستراکتور به ارث برده نمیشه.</li>\n<li>اگه کانستراکتور دارای default argument باشه، به همون صورت به ارث نمیرسه بلکه به صورت چند کانستراکتور overload شده به ارث میرسه.</li>\n<li>اگه یه کانستراکتور توی کلاس والد حذف بشه، توی کلاس فرزند هم حذف میشه.</li>\n</ul>\n<h2>در آخر</h2>\n<p>فصل بعدی درباره‌ی چند ریختی یا همون polymorphism عه که دانش ابتدایی ما برای برنامه نویسی شئ‌گرا رو کامل میکنه.</p>"}