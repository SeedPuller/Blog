{"expireTime":9007200880603433000,"key":"transformer-remark-markdown-html-4231bacd67635cf54918a69ccee8bde5-gatsby-remark-imagesgatsby-remark-audiogatsby-remark-external-linksgatsby-remark-prismjs-","val":"<p>در این فصل قراره که یاد بگیریم چطور با استفاده از iterator ها و\nalgorithm(الگوریتم) های موجود در کتابخانه استاندارد سی++ یا همون STL\nکارهامون رو پیش ببریم. یاد میگیریم که توابع لاندا چی هستن و چطور ازشون\nاستفاده بکنیم، اشاره گر به تابع چیه و چطور میشه ازش استفاده کرد و چیز\nهای دیگه.</p>\n<h2>نکاتی درباره پیمایش‌گر ها (Iterators)</h2>\n<p>اینکه یه کانتینر از چه iterator هایی پشتیبانی میکنه مشخص کنندهٔ اینه\nکه از چه الگوریتم هایی میشه برای این کانتینر استفاده کرد. به عنوان مثال\nکانتینر های vector و array. این دو کانتینر از random-access iterator\nپشتیبانی میکنن(وقتی از این نوع پشتیبانی میکنن یعنی از بقیه انواع پیمایش\nکننده ها هم پشتیبانی میکنن) و این یعنی همهٔ الگوریتم های موجود رو میشه\nبراشون استفاده کرد. البته نکته اینجاست که الگوریتم هایی که سایز کانتینر\nرو تغییر میدن برای array قابل استفاده نیستن. بنابراین مهم نیست که\nکانتینر چیه، اگه اون کانتینر، حداقل نوع iterator مورد نیاز برای یه\nالگوریتم رو ساپورت بکنه، میشه از اون الگوریتم براش استفاده کرد.</p>\n<h3>باطل شدن پیمایش ها (iterator invalidation)</h3>\n<p>ایتریتور ها درواقع یک اشاره گر کپسوله شدن هستند که به عناصر کانتینر\nاشاره میکنن بنابراین ممکنه در صورت بروز یک سری تغییرات در کانتینر (که به\nکانتینر بستگی داره)، این اشاره گر اعتبارشو از دست بده و باطل بشه. پروسه\ninvalidate شدن اشاره گر ها، رفرنس ها و ایتریتور ها در بخش 23 استاندارد\nسی++ موجوده و ما اینجا فقط خلاصه ای از اونها رو بررسی می‌کنیم.</p>\n<h4>اضافه کردن یه عنصر به کانتینر:</h4>\n<ul>\n<li>در <code class=\"language-text\">vector</code> ها، اگر اضافه کردن عنصر ما باعث بشه که\nوکتور اقدام به درخواست فضای بیشتر و در نتیجه reallocate شدن بکنه، تمام\niterator هایی که مربوط به این وکتور بودن باطل میشن. در غیر این صورت، هر\niterator ای که به فضای بین مکان عنصری که تازه اضافه شده و مکان آخرین\nعنصر موجود اشاره میکنه باطل میشه.</li>\n<li>در <code class=\"language-text\">deque</code> ها، همه iterator ها باطل میشن.</li>\n<li>در <code class=\"language-text\">list</code>, <code class=\"language-text\">forward_list</code> و ordered associative container ها هیچ تغییری در iterator ها بوجود نمیاد</li>\n<li>در unordered associative container ها تنها اگر عمل reallocation انجام بگیره، همه iterator ها باطل میشن.</li>\n</ul>\n<h4>حذف کردن یک عنصر از کانتینر باعث میشه iterator ای که به اون عنصر اشاره می‌کنه باطل بشه. علاوه بر اون:</h4>\n<ul>\n<li>در وکتور ها از اونجایی که عنصر حذف شده تا آخرین عنصر هر پیمایش‌گری وجود داشته باشه غیر فعال میشه</li>\n<li>در <code class=\"language-text\">deque</code> ها اگر حذفی که رخ داده در جایی غیر از ابتدا یا انتهای کانتینر باشه باعث میشه کل پیمایشگر ها باطل بشن.</li>\n</ul>\n<h2>توابع لاندا</h2>\n<p>خیلی از الگوریتم های موجود در STL میتونن <strong>یک تابع‌‌‌‌‌‌</strong>\nرو به عنوان ورودی خودشون داشته باشن. همونطور که قبلا می‌دونیم، اسم یک\nتابع به صورت ضمنی یک اشاره گر به ابتدای کد اون تابع هست. اما یک راه هم\nوجود داره که تابع خودمون رو منحصرا برای اون الگوریتمی که داریم ازش\nاستفاده میکنیم بنویسیم و اون رو دقیقا کنار بقیه آرگومان ها بنویسیم! برای\nاینکار یک مفهوم به اسم <strong>توابع لاندا</strong> به کارمون میاد که در واقع توابعی هستند که اسم ندارند و اصطلاحا بهشون میگن anonymous function.</p>\n<p>برای اینکه دقیق تر متوجه بشیم، یه مثال رو بررسی می‌کنیم:</p>\n<p>یکی از الگوریتم های جالبی که در STL وجود داره، اسمش <code class=\"language-text\">for_each</code>\nهست. این تابع میاد بازه ای از یک کانتینر رو میگیره و تابعی که ما بهش\nمیدیم رو برای تمام عناصر موجود در اون بازه اجرا میکنه. بهتره که کد رو\nببینیم:<img src=\"https://seedpuller.space/wp-content/uploads/2020/07/image-3.png\"></p>\n<p>خب همونطور که می‌بینیم، تابع <code class=\"language-text\">for_each</code> برای دوتا آرگومان\nاولش دوتا iterator میگیره و آرگومان سومش یه تابع رو به عنوان ورودی\nدریافت می‌کنه. توی این مثال ما دوتا for_each زدیم که اولی میاد و صرفا\nعناصر رو ضربدر ۲ میکنه و چاپ می‌کنه و دومی میاد جمع همهٔ عنصر هارو\nمحاسبه می‌کنه. چجوریش رو میگم حالا.</p>\n<h3>سینتکس توابع لاندا</h3>\n<p>خب آرگومان اول و دوم که واضحن. میمونه آرگومان سوم که یه تابع لانداست. سینتکس توابع لاندا این شکلی ان:</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token punctuation\">[</span>introducer<span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span>input arguments<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>function  body<span class=\"token punctuation\">}</span></code></pre></div>\n<p>خب همونطور که می‌بینید توابع لاندا با یک [] شروع میشن که اصطلاحا بهشون میگن <strong><em>lambda introducer</em></strong>. بقیه‌ش تقریبا مثل تابع معمولیه و  لیست پارامتر های ورودی میاد و در ادامه بدنه تابع قرار داره.</p>\n<p>توابع لاندا میتونن به متغییر های محلی(local) جایی که دارن داخلش تعریف\nمیشن دسترسی داشته باشن. مثلا توی مثال بالا تابع های لاندای ما میتونن به\nمتغییر هایی که داخل main تعریف شده دسترسی داشته باشن. اینجاست که lambda\nintroducer به کار میاد. درواقع lambda introducer به ما اجازه میده که\nمشخص کنیم از کدوم متغییر های موجود میخوایم استفاده کنیم. به اینکار\nاصطلاحا میگن <strong><em>capture</em></strong> کردن متغییر ها. </p>\n<p>توی اولین <code class=\"language-text\">for_each</code> می‌بینیم که lambda introducer خالیه و\nاین یعنی تابع لاندای ما نمیخواد از هیچ متغییری استفاده کنه. و توی دومی\nما این رو می‌بینیم: <code class=\"language-text\">[&amp;sum]</code> و این یعنی رفرنسی از متغییر <code class=\"language-text\">sum</code> رو در دسترس تابع قرار میده که ازش استفاده بکنه. دلیل اینکه از رفرنس استفاده شده هم اینه که بتونیم متغییر اصلی که داخل <code class=\"language-text\">main</code> قرار داره رو modify کنیم.</p>\n<h3>برگردوندن مقدار در توابع لاندا</h3>\n<p>تا الآن تابع های لاندای ما هیچ مقدار بازگشتی ای نداشتن و بنابراین به\nصورت پیشفرض مقدار بازگشتیشون به عنوان void مشخص میشد. اما اگر داخل تابع\nلاندامون یه return داشته باشیم نیاز داریم که نوع مقدار بازگشتی رو از\nطریق سینتکس trailing return type مشخص کنیم.</p>\n<p>اینطوریه : </p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token operator\">-></span> type</code></pre></div>\n<p>که اگر بخوام توی کد نشون بدم اینطوری میشه:</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token keyword\">int</span> <span class=\"token punctuation\">{</span><span class=\"token keyword\">return</span> <span class=\"token number\">2</span><span class=\"token punctuation\">}</span></code></pre></div>\n<p>همونطور که می‌بینیم، جاش بین لیست پارامتر ها و بدنه تابع‌ست.</p>\n<h2>الگوریتم ها</h2>\n<p>این بخش از فصل تعداد زیادی الگوریتم رو توضیح داده ولی من فقط اونایی که به نظرم بدرد بخور تر یا جالب تر میان رو اینجا می‌نویسم.</p>\n<h3><code class=\"language-text\">mismatch</code></h3>\n<p>وظیفهٔ این تابع اینه که بین دوتا کانتینر بگرده و اونجایی که دوتا خونه\nمتناظر باهم یک مقدار مساوی نداشته باشن، می‌ایسته و اطلاعات اون مکان رو\n(به شکل یک <code class=\"language-text\">pair</code> از iterator های هردو کانتینر) بهمون\nبرمیگردونه. این تابع ۴ تا ورودی داره(اونی که توی کتاب نشون داده\nاینطوریه) که دوتای اول بازه رو برای کانتینر اول مشخص میکنن و دوتای دوم\nبازه رو برای کانتینر دوم مشخص میکنن. </p>\n<h3>inserter ها</h3>\n<p>بیاین تابع merge رو باهم ببینیم:</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\">vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> a1<span class=\"token punctuation\">{</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\nvector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> a2<span class=\"token punctuation\">{</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">,</span> <span class=\"token number\">6</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\nvector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> result<span class=\"token punctuation\">;</span>\nstd<span class=\"token double-colon punctuation\">::</span><span class=\"token function\">merge</span><span class=\"token punctuation\">(</span>a1<span class=\"token punctuation\">.</span><span class=\"token function\">begin</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> a1<span class=\"token punctuation\">.</span><span class=\"token function\">end</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> a2<span class=\"token punctuation\">.</span><span class=\"token function\">begin</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> a2<span class=\"token punctuation\">.</span><span class=\"token function\">end</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> result<span class=\"token punctuation\">.</span><span class=\"token function\">begin</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>توی مثال بالا، وکتور result باید حتما به اندازه ۶ تا خونه جا داشته\nباشه تا a1 و a2 داخلش ذخیره بشن. بنابراین باید قبل از اجرای تابع <code class=\"language-text\">merge</code>، باید تخصیص حافظه صورت بگیره.</p>\n<p>اما زمانی هست که ما نمی‌خوایم از قبل حافظه ای تخصیص بدیم و میخوایم یک\nکلاسی مثل وکتور، خودش اینکار رو به ازای اضافه شدن عناصر جدید انجام بده.\nاینجاست که inserter ها (از هدر iterator) به کمک ما میان. مثال بالا اگر\nاجرا بشه به مشکل میخوره چراکه result به اندازه کافی جا نداره. حالا با\nاستفاده از inserter این مشکل رو برطرف می‌کنیم:</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\">vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> a1<span class=\"token punctuation\">{</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\nvector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> a2<span class=\"token punctuation\">{</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">,</span> <span class=\"token number\">6</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\nvector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">></span> result<span class=\"token punctuation\">;</span>\nstd<span class=\"token double-colon punctuation\">::</span><span class=\"token function\">merge</span><span class=\"token punctuation\">(</span>a1<span class=\"token punctuation\">.</span><span class=\"token function\">begin</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> a1<span class=\"token punctuation\">.</span><span class=\"token function\">end</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> a2<span class=\"token punctuation\">.</span><span class=\"token function\">begin</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> a2<span class=\"token punctuation\">.</span><span class=\"token function\">end</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">back_inserter</span><span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>تابع back<em>inserter درواقع میاد و به ازای هر عنصری که میخواد به result اضافه بشه، تابع `push</em>back` مربوط به کانتینر result رو صدا می‌زنه. به همین راحتی (:</p>\n<h2>Function Object ها</h2>\n<p>همونطور که می‌دونیم، بسیاری از الگوریتم های موجود در کتابخونه\nاستاندارد میتونن یک تابع رو به عنوان آرگومان آخرشون بگیرن. تا اینجا\nدیدیم که این تابع میتونه یک function pointer یا یک تابع لاندا (lambda\nfunction) باشه. کلاس هایی که میتونن توابع لاندا یا اشاره گر به توابع رو\nبه عنوان ورودی بگیرن، میتونن یک نوع دیگه از تابع رو هم دریافت کنن که\nاسمش function object هست. function object درواقع یک شئ از کلاسی هست که\nاوپراتور پرانتزش overload شده. یعنی ما در member function های کلاس، یک\nتابع به اسم <code class=\"language-text\">operator()</code> تعریف کردیم.</p>\n<p>اشیاء ای که از این کلاس ما ساخته میشن میتونن بجای تابع لاندا یا اشاره\nگر به تابع استفاده بشن.(درواقع خود توابع لاندا توسط کامپایلر به یک\nاشاره گر به تابع یا function object تبدیل میشن تا بشه روشون بهینه سازی\nانجام داد).</p>\n<p>در بیشتر جاها(و نه همه جا) میشه بجای function object از تابع لاندا یا اشاره گر به تابع استفاده کرد.</p>\n<p>از طریق هدر <code class=\"language-text\">&lt;functional></code> میتونیم به function object های از پیش تعریف شده <em>STL</em>\nدسترسی داشته باشیم که خیلی هم کاربردی و خفنن. تابع less<T> که توی\nمثال های بالا(بخش set و …) دیدیم جزئی از function object های موجود در <em>STL</em> عه.</p>\n<h3>مزایای function object ها</h3>\n<p>اولین تفاوتش با لاندا و امثالهم اینه که از اونجایی که عضوی از یک\nکلاسه، کامپایلر راحت تر میتونه بهینه سازی هایی مثل inline کردن رو انجام\nبده.</p>\n<p>دومین تفاوت که یک نقطه قوت محسوب میشه، قابلیت استفاده از data member های کلاس هست.</p>\n<h2>پایان</h2>\n<p>این فصل هم تموم شد. مثل فصل های قبلی با تاخیر اما برخلاف فصل های\nقبلی، تاخیرش زیاد نبود! فصل بعدی توی مدیریت استثنا ها و خطا ها عمیق\nمیشیم.</p>"}