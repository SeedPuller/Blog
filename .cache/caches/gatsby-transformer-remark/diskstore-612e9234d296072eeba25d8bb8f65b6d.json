{"expireTime":9007200880603433000,"key":"transformer-remark-markdown-html-6cf261b6e213cce461d501645a9f65f3-gatsby-remark-imagesgatsby-remark-audiogatsby-remark-external-linksgatsby-remark-prismjs-","val":"<p>توی این فصل سه بخش از کتابخانه استاندارد سی++ که بهش STL هم میگن رو\nبررسی می‌کنیم. container ها، iterator ها و algorithm ها. فصل بسیار مهمیه\nچراکه این کتابخونه بسیاری از کار های مارو راحت تر می‌کنه و اگر خوب بلد\nباشیم ازش استفاده کنیم، دهن خودمون رو برای پیاده سازی کردن خیلی از چیز\nها صاف نمی‌کنیم.</p>\n<h2>کانتینر ها</h2>\n<p>کانتینر ها یک ساختمان داده ای هستند که تقریبا میشه همه نوع داده ای رو\nتوشون ذخیره کرد. درکل سه نوع کانتینر داریم که به شکل زیر دسته بندی\nمیشن:</p>\n<ul>\n<li>first class containers</li>\n<li>container adapters</li>\n<li>near containers</li>\n</ul>\n<p>یک نوع دسته بندی دیگه هم وجود داره که کانتینر هارو به ۴ بخش تقسیم می‌کنه:</p>\n<ul>\n<li>Sequence containers</li>\n<li>Ordered associative containers</li>\n<li>unordered associative containers</li>\n<li>container adapters</li>\n</ul>\n<p>بخش sequence containers و associative containers درواقع به عنوان first class container در نظر گرفته میشن.</p>\n<p>container adapter در اصل همون first class container ها هستن که عملیات هاشون محدود شده. این کانتینر شامل استک، صف و … هست.</p>\n<p>یک نوع کانتینر دیگه هم داریم که بهشون میگن near containers. دلیل\nاینکه اسمشون رو به این شکل انتخاب کردن اینه که این کانتینر ها بعضی از\nقابلیت های first-class container هارو دارن و بخش دیگه ایشون رو ندارن.\nمثالی که میشه از این کانتینر ها زد؟ built-in array ها، کلاس های مربوط به\n<code class=\"language-text\">bitset</code> و <code class=\"language-text\">valarray</code> ها(که برای انجام عملیات های سریع ریاضی روی وکتور ها* بکار میره) و …</p>\n<p>*اون وکتور، با <code class=\"language-text\">vector</code> ای که توی کانتینر ها داریم فرق داره.</p>\n<p>توی جدول زیر میتونیم لیست کانتینر ها و ویژگی‌هاشون رو ببینیم که خیلی جالبه:<img src=\"https://seedpuller.space/wp-content/uploads/2020/07/image.png\"></p>\n<p><img src=\"https://seedpuller.space/wp-content/uploads/2020/07/image-1.png\"></p>\n<p><img src=\"https://seedpuller.space/wp-content/uploads/2020/07/image-2.png\"></p>\n<h4>نکاتی درباره پرفورمنس کانتینر ها</h4>\n<ul>\n<li>اضافه/حذف کردن به/از آخر vector ها سریعه. اما اضافه/حذف کردن به/از اول و یا وسط vector ها به صرفه نیست</li>\n<li>اگر\nنیاز داریم که صورت مفرط به ابتدا/انتها کانتینرمون المان اضافه(یا حذف)\nبکنیم بهتره از deque (تلفظ میشه دِکْ) استفاده بکنیم چرا که عملیات هاش در\nابتدا و انتهای کانتینر سریعن</li>\n<li>در آخر اگه نیاز داریم که در وسط کانتینر هم چیزی رو حذف کنیم یا اضافه کنیم، بهتره از list استفاده بکنیم.</li>\n</ul>\n<p><strong>Sequence Container ها:</strong></p>\n<h3>وکتور ها (<code class=\"language-text\">vector</code>)</h3>\n<p>وکتور کانتینری هست که از خونه های متوالی حافظه استفاده میکنه. در واقع\nدر لایه های زیرین وکتور میاد و با یک اندازه ثابت یک آرایه تخصیص میده.\nبعد از پر شدن آرایه، یک آرایه با اندازهٔ بیشتر از حافظه میگیره و اطلاعات\nآرایه قبلی رو در آرایه جدید کپی میکنه(یا move میکنه) و آرایه قبلی رو\nحذف می‌کنه. در واقع این قابلیت آرایه بودن این امکان رو بهش میده که بشه\nبه صورت آنی به المان های وکتور دسترسی پیدا کرد.</p>\n<p>اگر می‌دونیم که حدودا قراره چه مقدار داده به وکتور اضافه کنیم، بهتره\nبا استفاده از توابع resize یا reserve اون حافظه رو برای وکتور بگیریم تا\nاز تخصیص و حذف پی در پی حافظه جلوگیری کنیم. C++11: shrink<em>to</em>fit</p>\n<p>اینکه چطور یک وکتور اقدام به افزایش حافظه میکنه بستگی به پیاده سازی\nداره و ممکنه توی کامپایلر های مختلف، نتیجهٔ متفاوتی داشته باشه. در حالت\nکلی این یک time-space tradeoff هست.</p>\n<h4>فرق بین <code class=\"language-text\">clear</code> و <code class=\"language-text\">erase</code></h4>\n<p>فرق این دو این هست که تابع clear کل اعضای وکتور رو پاک میکنه اما\nerase این قابلیت رو داره که تک عضو و یا یک رنج از عضو ها رو از وکتور پاک\nکنه.</p>\n<h3>لیست ها (<code class=\"language-text\">list</code>)</h3>\n<p>لیست که درواقع یک لیست دو پیوندی هست (doubly linked list) اجازهٔ\nاضافه و حذف کردن سریع در هر جای کانتینر رو میده اما در حالت کلی اگر\nبیشتر عملیات هامون قراره در دو انتهای کانتینر باشه، بهتره که از دِک\n(deque) استفاده کنیم.</p>\n<h4>تابع <code class=\"language-text\">unique</code></h4>\n<p>این تابع عناصر تکراری یه کانتینر رو حذف می‌کنه. البته برای اینکه درست\nکار کنه کانتینر ما از قبل باید سورت شده باشه تا عناصر تکراری کنار هم\nقرار بگیرن.</p>\n<h3>دِک ها (<code class=\"language-text\">deque</code>)</h3>\n<p>کلاس دک درواقع نکات مثبت وکتور و لیست رو توی خودش جمع کرده. کلمهٔ\ndeque کوتاه شدهٔ double-ended queue هست. این کلاس قابلیت دسترسی سریع و\nمستقیم به عناصر داره و همچنین عملیات هایی که در دو سمت انتهایی این\nکانتینر انجام میشن سریعن.</p>\n<p>از اونجایی که از random-access iterator ها ساپورت میکنه بنابراین همهٔ\nالگوریتم های کتابخونه استاندارد میتونن روی این کلاس اعمال بشن.</p>\n<p>در حالت کلی دک سربار بیشتری از وکتور داره و همچنین حذف و اضافه کردن در وسط دک ها بهینه تر از وکتوره(همچنان کند تر از لیست ها)</p>\n<p><strong>حالا که یک دید کلی از Sequence container ها داریم، به Associative Container ها می‌پردازیم:</strong></p>\n<p>این کانتینر ها قابلیت این رو به ما میدن که با استفاده از یک کلید\nبتونیم به صورت مستقیم به مقادیر مورد نظرمون دسترسی داشته باشیم. ۸ نوع\nکلاس وجود داره که ۴ تای اول کلید هارو به صورت مرتب ذخیره میکنن و ۴ تای\nدوم، ترتیب کلید ها براشون مهم نیست.</p>\n<ul>\n<li><code class=\"language-text\">multiset</code>, <code class=\"language-text\">set</code>, <code class=\"language-text\">multimap</code>, <code class=\"language-text\">map</code></li>\n<li><code class=\"language-text\">unordered_multiset</code>, <code class=\"language-text\">unordered_set</code>, <code class=\"language-text\">unordered_multimap</code>, <code class=\"language-text\">unordered_map</code></li>\n</ul>\n<p>کلاس های <code class=\"language-text\">set</code> و <code class=\"language-text\">multiset</code> به ما یه مجموعه ای از مقادیر رو میدن که خود اون مقدار ها، کلید هم هستن. فرق اصلی این دو کلاس اینه که کلاس <code class=\"language-text\">set</code> اجازه نمیده مقادیر تکراری به مجموعه اضافه بشن اما کلاس <code class=\"language-text\">multiset</code> این اجازه رو میده.</p>\n<p>کلاس های <code class=\"language-text\">map</code> و <code class=\"language-text\">multimap</code> یه مجموعه به ما میدن که هر کلید، به یک مقدار وصله. فرقشون هم اینه که در کلاس <code class=\"language-text\">map</code> نمیشه یک کلید چند مقدار متفاوت داشته باشه اما این امر توی <code class=\"language-text\">multimap</code> امکان پذیره.</p>\n<h3>کلاس <code class=\"language-text\">multiset</code></h3>\n<p>این کلاس که از هدر <code class=\"language-text\">&lt;set></code> میتونیم بهش دسترسی داشته\nباشیم به ما قابلیت ذخیره سازی و بازیابی سریع مقادیر رو میده همچنین\nقابلیت این رو داره مقادیر تکراری رو ذخیره کنه. این کلاس برای مرتب کردن\nعناصرش از چیزی به نام <em>comparator function object</em> استفاده می‌کنه که توی فصل بعد بهش می‌پردازیم. اگر ترتیب مقدار ها مهم نیست بهتره که از <code class=\"language-text\">unordered_multiset</code> استفاده بکنیم چراکه سربار کمتری داره(هدر<code class=\"language-text\">&lt;unordered_set></code>) . مثال برای استفاده از multiset:</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\">std<span class=\"token double-colon punctuation\">::</span>multiset <span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> less<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">>></span> values<span class=\"token punctuation\">;</span></code></pre></div>\n<p>که در اینجا اون <code class=\"language-text\">less&lt;int></code> یک comparator function object هست(اختیاری) و باعث میشه مقادیر ما به صورت صعودی مرتب بشن.</p>\n<h3>کلاس <code class=\"language-text\">set</code></h3>\n<p>این کلاس تنها فرقی که با <code class=\"language-text\">multiset</code> داره اینه که عناصر تکراری رو ignore میکنه و درواقع همهٔ عناصر موجود در اون، یکتا هستن.</p>\n<h3>کلاس <code class=\"language-text\">multimap</code></h3>\n<p>این نوع از associative container  که از طریق هدر <code class=\"language-text\">map</code>\nمیشه بهش دسترسی داشت به ما این قابلیت رو میده که مقادیر رو به صورت «جفت»\n(pair) ذخیره کنیم. یعنی اینکه به ازای هر مقدار، یک کلید وجود داره.\nاینکه کلید ها به چه ترتیبی مرتب بشن رو میشه از طریق comparator function\nها تعیین کرد. کلاس <code class=\"language-text\">multimap</code> اجازه میده که کلید های تکراری داشته باشیم یعنی یک کلید میتونه چندین مقدار داشته باشه که بهش میگن <em>one-to-many relationship</em> و احتمالا بخاطر همینه که برای این کلاس random-access iterator نذاشتن.</p>\n<h3>کلاس <code class=\"language-text\">map</code></h3>\n<p>این کلاس شبیه <code class=\"language-text\">multimap</code> عه تنها با این تفاوت که امکان وجود کلید تکراری نیست. یعنی هر کلید فقط به یک مقدار اشاره میکنه (<em>one-to-one mapping</em>) و همچنین این قابلیت وجود داره که به مقدار هر کلید به صورت آنی دسترسی داشته باشیم. ( با استفاده از اوپراتور []).</p>\n<p>هردو کلاس قبلی که گفته شد دارای یک نسخه غیر مرتب هم هستند که سربار کمتری داره و برای استفاده ازشون کافیه یه <code class=\"language-text\">unordered_</code> پشت اسم کلاس بذاریم.</p>\n<p><strong>نکاتی درباره Container Adapter ها:</strong></p>\n<p>این کانتینر ها در اصل همون first class container ها هستند که عملیات\nهاشون محدود شده و از iterator پشتیبانی نمی‌کنن. بنابراین لایه زیرین کلاس\nهای این کانتینر از کلاس های first class container ها تشکیل میشه.</p>\n<ul>\n<li>کلاس stack که یک استک رو میسازه، به صورت پیشفرض از deque استفاده می‌کنه.</li>\n<li>کلاس queue که یک صف رو میسازه، به صورت پیشفرض از deque استفاده می‌کنه.</li>\n<li>کلاس\npriority_qeueu که یک صف اولویت دار رو میسازه(صفی که مقادیر داخلش معمولا\nبا استفاده از تکنیک heap، مرتب شده‌ند)، به صورت پیش‌فرض از کلاس vector\nبه عنوان لایه زیرین خودش استفاده می‌کنه comparator function هم داره.</li>\n</ul>\n<h2>پیمایش کننده ها (Iterators)</h2>\n<p>ایتریتور ها چیزی شبیه به پوینتر ها هستند که قابلیت های بیشتری دارن و\nبرای دسترسی و تغییر المان های یک کانتینر بکار میرن. مکانیسم دسترسی و\nپیمایش در یک کانتینر رو کپسوله میکنن و این به الگوریتم ها اجازه میده که\nبدون وابستگی به پیاده سازی لایه کانتینر، بتونن کار خودشون رو انجام بدن.</p>\n<p>چند تابع داریم که میتونن برامون یک iterator برای یک کانتینر و یا حتی یک آرایه بسازن.</p>\n<p>توابع <code class=\"language-text\">begin</code> و <code class=\"language-text\">end</code> که یک اشاره گر به اعضاء کانتینر میسازن( از سی++ ۱۱ به بعد میتونن یک پوینتر از built-in array ها بسازن حتی) و توابع <code class=\"language-text\">cbeing</code>, <code class=\"language-text\">cend</code> که یک ایتریتور const میسازن و <code class=\"language-text\">rbegin</code>, <code class=\"language-text\">rend</code>, <code class=\"language-text\">crbegin</code>, <code class=\"language-text\">crend</code> که قابلیت پیمایش برعکس روی یک آرایه رو میدن(از سی++ ۱۴ به بعد).</p>\n<h2>الگوریتم ها</h2>\n<p>الگوریتم ها شامل پیاده سازی ساختمان داده ها، الگوریتم های جستجو،\nمقایسه و مرتب سازی هستن که معمولا از ایتریتور ها استفاده میکنن. ایتریتور\nهایی که یه کانتینر ساپورت میکنه مشخص میکنه که آیا اون کانتینر میتونه از\nیه الگوریتم خاص استفاده بکنه یا نه. در مورد این بخش توی فصل بعدی کتاب\nبه صورت مفصل بحث شده.</p>\n<p>خب این فصل تقریبا طولانی هم تموم شد. هرچند مثل همیشه خیلی روش تمرکز\nنداشتم. اما تازگی دارم از تکنیک پومودورو استفاده می‌کنم و فعلا که جواب\nداده. فصل بعد هم درباره کتابخانه استاندارد صحبت می‌کنیم و بیشتر تمرکزمون\nروی بخش الگوریتم های این کتابخونه هست. بوس.</p>"}