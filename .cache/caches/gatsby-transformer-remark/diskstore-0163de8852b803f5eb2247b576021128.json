{"expireTime":9007200880603433000,"key":"transformer-remark-markdown-html-1751b791424d8f40731d7e0e81370c30-gatsby-remark-imagesgatsby-remark-audiogatsby-remark-external-linksgatsby-remark-prismjs-","val":"<p>خب فصل ۱۰ ام از کتاب برنامه نویسی سی++ دایتل رو تموم کردم. اینجا خلاصه ای از چیزای جدیدی که یادگرفتم رو می‌نویسم.</p>\n<h2>string-object literal</h2>\n<p>توی سی++ ۱۴ میشه با اضافه کردن یک s به انتهای لیترال رشته‌ای‌مون(بعد\nاز دابل کوتیشن، نه قبلش) اون رشته رو تبدیل به یه شئ از کلاس <code class=\"language-text\">string</code> کرد. مثال:</p>\n<p><code class=\"language-text\">\"Hello, World\"s</code></p>\n<h2>Operator Overloading؛ به عنوان عضو کلاس یا نه؟</h2>\n<p>با اینکه من قبلا این بخش هارو توی کتاب C How To Program خونده بودم\nاما چون یادداشت نکرده بودم و خیلی وقت هم شده بود که حوصله‌ی برنامه نویسی\nرو نداشتم، یادم رفته بود.</p>\n<p>مسئله اینه که چه وقتی باید تابع اوپراتوری که overload میشه رو جزئی از\nmember function ها بذاریم و چه وقتی جزئی از non-member function.\nساده‌ست، تنها زمانی میتونیم تابع اوپراتور رو به عنوان عضوی از کلاس قرار\nبدیم که شئِ کلاس ما به عنوان پارامتر در سمت چپ قرار بگیره. این کد رو\nببینید:</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\">istream<span class=\"token operator\">&amp;</span> <span class=\"token keyword\">operator</span><span class=\"token operator\">>></span><span class=\"token punctuation\">(</span>istream<span class=\"token operator\">&amp;</span> input<span class=\"token punctuation\">,</span> MyClass<span class=\"token operator\">&amp;</span> object<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>وقتی مینویسیم <code class=\"language-text\">cin >> myobject</code> درواقع انگار تابع رو به شکل <code class=\"language-text\">operator>>(input, myobject)</code> فراخوانی کردیم. </p>\n<p>حالا از اونجایی که شئ ما توی پارامتر سمت چپ قرار نمیگیره، نمیتونیم\nاین اوپراتور رو داخل کلاس overload کنیم و اگر اینکارو انجام دادیم، باید\nاینطوری بنویسیمش: <code class=\"language-text\">myobject &lt;&lt; cin</code></p>\n<p>از طرف دیگه، برای اینکه بتونیم اوپراتور هامون رو به صورت\ncommutative(جابجایی پذیر) تعریف کنیم، به دلایلی که بالاتر توضیح داده شد\nباید حداقل یکبار اوپراتورمون رو به عنوان non-member function تعریف کنیم.</p>\n<h2>نکته درباره‌ی Dynamic Allocation در عضو های کلاس</h2>\n<p>وقتی یک حافظه ای رو به صورت پویا برای یکی از اعضای کلاس‌مون (data-member) در نظر می‌گیریم باید حواسمون باشه که Default\nmemberwise assignment و Default copy constructor رو به حال خودشون رها\nنکنیم چون مشکلاتی مثل double free رو بوجود میارن. پس یادمون باشه که کپی\nکانستراکتور خودمون + علامت مساوی(=) خودمون رو تعریف کنیم.</p>\n<h2>حذف یه تابع از کلاس</h2>\n<p>یه تابع از کلاس (function member) رو میشه حذف کرد. قبلا برای اینکار،\nاون تابع رو جزء بخش private کلاس قرار می‌دادند اما الان به عنوان مثال\nمیشه اینطوری نوشت: </p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">const</span> Array<span class=\"token operator\">*</span> <span class=\"token keyword\">operator</span><span class=\"token operator\">=</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> Array<span class=\"token operator\">*</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">delete</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>کاربردش چیه؟ معمولا برای غیرفعال کردن توابعی که توسط کامپایلر به صورت\nخودکار ساخته میشن (auto generate)، مثل سازنده‌ی پیشفرض(Default\nconstructor)، کپی کانستراکتور، اوپراتور تخصیص (=) و … استفاده می‌شن.</p>\n<h2>تعریف شئ از کلاس با initializer list</h2>\n<p>برای اینکه بتونیم یه شئ از کلاسمون رو با initializer list بسازیم، باید یه کانستراکتور داشته باشیم که ورودی‌ش از نوع <code class=\"language-text\">initializer_list</code>باشه. مثال: </p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token class-name\">MyClass</span><span class=\"token double-colon punctuation\">::</span><span class=\"token function\">MyClass</span><span class=\"token punctuation\">(</span>initializer_list list<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h2>تبدیل انواع مختلف به کلاس و بالعکس</h2>\n<p>ما میتونیم اشیاء ای که از کلاسمون میسازیم رو با استفاده از Conversion\nConstructor ها و Conversion Operator ها به انواع دیگه ای تبدیل کنیم. </p>\n<p>برای اینکه یه کانستراکتور تبدیل کننده داشته باشیم نیاز داریم که\nکانستراکتور ما بتونه با یک آرگومان صدا زده بشه.(این مسئله برای کپی\nکانستراکتور ها صادق نیست) مثال : </p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token class-name\">MyClass</span><span class=\"token double-colon punctuation\">::</span><span class=\"token function\">MyClass</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>حالا با استفاده از این تابع میشه هم به صورت ضمنی و هم به صورت مستقیم یک int رو به شئ ای از کلاس خودمون تبدیل کنیم.</p>\n<p>برای تعریف یک Conversion Operator میتونیم اینطوری عمل کنیم:</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\">MyClass<span class=\"token double-colon punctuation\">::</span><span class=\"token keyword\">operator</span> <span class=\"token function\">string</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">const</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>حالا اگر فرض کنیم <code class=\"language-text\">a</code> اسم شئ ما باشه، وقتی بنویسیم <code class=\"language-text\">static_cast&lt;string> (a)</code> درواقع کامپایلر تابع <code class=\"language-text\">a.operator string()</code> رو صدا میزنه.</p>\n<h2>چرا توابع سازنده‌مون رو به شکل <code class=\"language-text\">explicit</code> تعریف کنیم؟</h2>\n<p>توابع سازنده ای که میتونن فقط با یک آرگومان صدا زده بشن ممکنه توسط\nکامپایلر اشتباها به عنوان Conversion Constructor تلقی بشن(چون این تابع\nها هم با یک ورودی صدا زده میشن) و به صورت ضمنی عمل cast رو انجام بدن.\nدرکل ما برای اینکه از تبدیل ضمنی چه توی کانستراکتور(اونایی که میتونن با\nیه آرگومان صدا زده بشن) و چه توی اوپراتور های تبدیلی( conversion\noperator) جلوگیری کنیم، اون توابع رو به صورت explicit تعریف می‌کنیم.</p>\n<p>فصل بعدی درباره‌ی ارث‌بری هست </p>"}