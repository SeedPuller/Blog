{"expireTime":9007200880603431000,"key":"transformer-remark-markdown-html-2620fd2ae1c2a5c138c1cb8876ec7f7f-gatsby-remark-imagesgatsby-remark-audiogatsby-remark-external-linksgatsby-remark-prismjs-","val":"<p>در پست قبل درباره اینکه چه کار های دیگه‌ای میشه با mutex ها انجام داد صحبت کردیم و همچنین کلاس <code class=\"language-text\">std::unique_lock</code> رو معرفی کردیم که دست ما رو برای استفاده از mutex ها باز می‌کنه. در این پست قراره که جایگزین های میوتکس ها رو بررسی کنیم و سناریو هایی رو ببینیم که برای پیاده سازیشون نیازی به استفاده از میوتکس نیست.</p>\n<p>با اینکه میوتکس ها یکی از پر کاربرد ترین مکانیزم ها برای محافظت از داده ها هستن ولی تنها گزینه نیستن. جایگزین های بسیاری برای این منظور وجود دارن که در بعضی از شرایط کاملا انتخاب معقول‌تری به نسبت میوتکس ها هستند.</p>\n<h2>محافظت از داده اشتراکی فقط در زمان ساخته شدن</h2>\n<p>بعضی وقت ها هست که تنها Modification ای که روی داده ما صورت می‌گیره، همون موقع ساختنشه! مثلا اگر که داده ساخته و Initialize شد عملا تبدیل به یک داده read-only یا همون «فقط خواندنی می‌شه» و  همونطور که می‌دونیم، داده ای که فقط برای خوندن مورد استفاده قرار می‌گیره نیاز به حفاظت نداره!</p>\n<p>قبل از اینکه این بحث رو ادامه بدم نیازمند این هستیم که با مفهوم Lazy Initialization آشنا باشیم.</p>\n<h3>مقدار دهی اولیه با تاخیر یا Lazy Initialization</h3>\n<p>فرض کنید یک منبع(Resource) ای داریم که ساختن و مقدار دهی اولیه‌ش کاری‌ست بس سنگین! (مثلا نیازمند تخصیص مقدار زیادی حافظه) انقدری که بهتره فقط زمانی که میخوایم از ریسورس استفاده بکنیم بیایم و بسازیمش/مقداردهی‌ش کنیم. به این می‌گن <strong>Lazy Initialization</strong></p>\n<p>توی برنامه های تک تردی این کار ساده‌ست؛ فقط کافیه قبل از استفاده از اون داده چک کنیم که آیا هنوز مقدار دهی شده یا نه. چیزی شبیه به کد زیر:</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\">std<span class=\"token double-colon punctuation\">::</span>shared_ptr<span class=\"token operator\">&lt;</span>some_resource<span class=\"token operator\">></span> resource_ptr<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>resource_ptr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n\t\tresource_ptr<span class=\"token punctuation\">.</span><span class=\"token function\">reset</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> some_resource<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n\tresource_ptr<span class=\"token operator\">-></span><span class=\"token function\">do_something</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>حالا اگر بخوایم همینکار رو با یک کد چند-نخی(multi thread) بکنیم چطوری میشه؟‌ اولین چیزی که به ذهن میرسه اینه که «خب میایم و با استفاده از Mutex داده رو محافظت می‌کنیم و چک می‌کنیم که آیا مقداردهی شده یا نه.». چیزی شبیه به این کد:</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\">std<span class=\"token double-colon punctuation\">::</span>shared_ptr<span class=\"token operator\">&lt;</span>some_resource<span class=\"token operator\">></span> resource_ptr<span class=\"token punctuation\">;</span>\nstd<span class=\"token double-colon punctuation\">::</span>mutex resource_mutex<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n\tstd<span class=\"token double-colon punctuation\">::</span>unique_lock<span class=\"token operator\">&lt;</span>std<span class=\"token double-colon punctuation\">::</span>mutex<span class=\"token operator\">></span> <span class=\"token function\">lk</span><span class=\"token punctuation\">(</span>resource_mutex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// checkpoint 1</span>\n\t<span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>resource_ptr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n\t\tresource_ptr<span class=\"token punctuation\">.</span><span class=\"token function\">reset</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> some_resource<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n\tlk<span class=\"token punctuation\">.</span><span class=\"token function\">unlock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\tresource_ptr<span class=\"token operator\">-></span><span class=\"token function\">do_something</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>اما این کد مشکلی داره! اونم اینکه همه ترد ها باید در checkpoint شماره ۱ منتظر بمونن تا قفل آزاد بشه تا اونا هم بتونن قفل کنن و ببینن که آیا داده مقدار دهی شده یا نه! و فقط هم یکی از این ترد ها (اولی‌شون) هست که میره و داده رو مقداردهی می‌کنه. بقیه فقط الکی چک می‌کنن. پس یه چیزی درست نیست... بقیه ترد ها اینجا گیر می‌کنن و به نوعی یک bottle-neck ایجاد شده. راه حل چیه؟ </p>\n<p>اول باید ببینیم دقیقا چی می‌خوایم. چیزی که ما میخوایم اینه: فقط یکبار مقداردهی صورت بگیره و دفعات بعد فقط از اون داده استفاده بشه.</p>\n<h3>استفاده از <code class=\"language-text\">std::call_once</code></h3>\n<p>دوستان خوب ما در کمیته استاندارد سی++ اومدن و چیزی رو تحت عنوان <code class=\"language-text\">std::once_flag</code> و <code class=\"language-text\">std::call_once</code> پیاده سازی کردن. با استفاده از این دو کلاس می‌تونیم دقیقا اون چیزی که میخواستیم رو پیاده سازی بکنیم. کد بالا به این شکل تبدیل می‌شه:</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\">std<span class=\"token double-colon punctuation\">::</span>shared_ptr<span class=\"token operator\">&lt;</span>some_resource<span class=\"token operator\">></span> resource_ptr<span class=\"token punctuation\">;</span>\nstd<span class=\"token double-colon punctuation\">::</span>once_flag resource_flag<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">init_resource</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n\tresource_ptr<span class=\"token punctuation\">.</span><span class=\"token function\">reset</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> some_resource<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n\tstd<span class=\"token double-colon punctuation\">::</span><span class=\"token function\">call_once</span><span class=\"token punctuation\">(</span>resource_flag<span class=\"token punctuation\">,</span>init_resource<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\tresource_ptr<span class=\"token operator\">-></span><span class=\"token function\">do_something</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>تابع <code class=\"language-text\">std::call_once</code> این اطمینان رو میده که فقط و فقط یکبار تابع مورد نظر ما رو اجرا بکنه.(و اینکار رو با کمک <code class=\"language-text\">std::once_flag</code> انجام می‌ده). درواقع اون flag کمک به فهم این موضوع می‌کنه که آیا تابع هدف ما قبلا اجرا شده یا نه.</p>\n<p>به این ترتیب به راحتی ترد های مختلف می‌تونن با خیال راحت از داده‌شون استفاده بکنن.</p>\n<blockquote>\n<p>استفاده از <code class=\"language-text\">std:call_once</code> سریعتر و بهینه تر از mutex هاست.</p>\n</blockquote>\n<h3>استفاده از <code class=\"language-text\">static</code></h3>\n<p>بله! تا قبل از سی++۱۱ استفاده از متغییر های <code class=\"language-text\">static</code> برای خودش معضلی بود(چون مثلا ترد ها سعی می‌کردن باهمدیگه یک متغییر رو مقداردهی کنن)  اما بعد از سی++ ۱۱ این مشکل برطرف شد. حالا وقتی یک متغییر <code class=\"language-text\">static</code> داریم میتونیم مطمئن باشیم که فقط یکی از ترد ها عمل مقداردهی رو انجام می‌ده و بقیه اینکار رو نمی‌کنن. شبیه به مکانیزم <code class=\"language-text\">std::call_once</code> (:</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">my_class</span><span class=\"token punctuation\">;</span>\nmy_class<span class=\"token operator\">&amp;</span> <span class=\"token function\">get_my_class_instance</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">static</span> my_class instance<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">return</span> instance<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>در این کد، هر چندتا ترد هم که تابع <code class=\"language-text\">get_my_class_instance()‍</code> رو فراخوانی بکنن، از <code class=\"language-text\">instance</code> فقط یکبار ساخته میشه(اولین تردی که بتونه این تابع رو فراخوانی بکنه، میسازتش). به همین زیبایی (:</p>\n<p>محافظت از داده ها «فقط برای زمان ساخته شدن» یک مثال کوچیکی بود از یک مفهوم کلی تر: <strong>ساختمان داده هایی که نسبت تعداد خوانده شدنشون خیلی بیشتر از نوشته شدنشونه</strong></p>\n<p>یعنی چی؟ یعنی ساختمان داده ای داریم که در اکثر موارد فقط ازش برای خوندن استفاده می‌شه و خیلی کمتر پیش میاد که نیاز باشه این ساختمان داده رو آپدیت بکنیم. مثالی که کتاب زده خیلی خوبه: DNS! بله دقیقا DNS یا فارسی‌ش که می‌شه «ساناد» (مخفف <strong>سا</strong>مانه <strong>نا</strong>م <strong>د</strong>امنه) مثال عملی همین توضیح است. ساناد ها خیلی کم آپدیت می‌شن و بیشتر اوقات فقط خونده میشن. و همونطور هم که می‌دونیم، «اشکالی نداره که چندتا ترد همزمان از یک منبع چیزی رو بخونن».</p>\n<h2>محافظت از ساختمان داده های به ندرت به‌روز شونده</h2>\n<p>همونطور که دیدیم، چیز هایی مثل ساناد وجود دارن که بیشتر از نوشتن، عمل خوندن روشون صورت می‌گیره. اما بهرحال این به‌روز رسانی ها هرچقدر هم کم باشن، بالاخره اتفاق می‌افتن و باید داده رو در این زمان محافظت کرد.</p>\n<p>یک راه حل اینه که ساختمان داده‌مون رو طوری طراحی کنیم که ذاتا در مقابل همچین چیزی مقاوم باشه. یعنی به شکل ذاتی قابلیت این رو داشته باشه که عملیات های خوندن و نوشتن به شکل همزمان روش انجام بشه و آخ نگه. اما این داستان مربوط میشه به فصل ۶ و ۷ کتاب و خب ما هنوز تازه فصل ۳ ایم ((((:</p>\n<p>راه بعدی اینه که بیایم یک دسترسی اختصاصی برای آپدیت کردن ساختمان‌مون ایجاد بکنیم. دقیقا همون کاری که میوتکس ها انجام می‌دادن. یک دسترسی mutual exclusive ایجاد می‌کردن. اما خب... اگر قرار باشه از میوتکس برای محافظت استفاده بکنیم، عملا همش برای خوندن داده ها هم ترد ها باید منتظر بمونن که این قفل لعنتی آزاد بشه دیگه نه؟ آره. درسته.</p>\n<p>برای همینه که ما به یک نوع جدیدی از mutex ها نیاز داریم! بله! دیگر زمان بدبختی به پایان رسید! نیازمند پیشرفت و بیرون آمدن از انزوا هستیم! ای ملت! بشتابید! به حرف های این عقب افتاده ها که استفاده از میوتکس کورشان کرده و از تعصب آن شقیقه هایشان داغ شده گوش ندهید! دوران تاریکی به سر آمد! فقط کافی‌ست ۱ عدد بیتکوین به حساب بنده واریز نمائید تا همه این مشکلات را برای شما حل بنمایم و همچنین باهم به بستنی فروشی می‌رویم و در اسرع وقت یک تونل از خوابگاه پسران به دختران حفر خواهم کرد. رای فراموش نشه!</p>\n<p>به این نوع جدید از mutex ها اصطلاحا می‌گن میوتکس های <em>reader-writer</em>. چرا؟‌ بخاطر اینکه دو جور دسترسی ایجاد می‌کنن:</p>\n<ol>\n<li>یک دسترسی اختصاصی برای نوشتن توسط «فقط یک ترد»</li>\n<li>چند دسترسی همزمان برای خواندن توسط «چندین ترد» </li>\n</ol>\n<p> در سی++ ۱۷ گرامی ما کلاسی هست به اسم <code class=\"language-text\">std::shared_mutex</code> که برای همین منظور ساخته شده. البته به نظر در فصل ۸ متوجه می‌شیم که این میوتکس ها تنها و بهترین راه نیستن و انتخاب این راه منوط به خیلی چیز ها از جمله نسبت خواندن/نوشتن هست.</p>\n<p>برای قفل کردن این نوع میوتکس ها به شکل <strong>اختصاصی</strong> میتونیم از کلاس های قبلی مثل <code class=\"language-text\">std::scopred_lock</code> یا <code class=\"language-text\">std::lock_guard</code>  استفاده کنیم. اما برای قفل کردن به شکل <strong>مشترک</strong> نیازمند این هستیم که از <code class=\"language-text\">std::shared_lock</code> استفاده بکنیم. فرق اینها چیست؟ خب <code class=\"language-text\">std::shared_lock</code> که از لحاظ اینترفیس کاملا شبیه به <code class=\"language-text\">std::unique_lock</code> هست. چندین ترد می‌تونن یک <code class=\"language-text\">std::shared_mutex</code> رو باهمدیگه در اختیار داشته باشن و به شکل مشترک قفل کنن. در این وضعیت، اگر تردی بخواد به شکل اختصاصی قفل رو انجام بده باید صبر کنه که همهٔ ترد های دیگه، قفل مشترک‌شون رو باز کنن. و وقتی که دسترسی اختصاصی توسط <code class=\"language-text\">std::scoped_lock</code> یا امثالهم ایجاد شد، دیگه هیچ ترد دیگه ای نمیتونه چه دسترسی مشترک و چه دسترسی اختصاصی ایجاد بکنه و باید تا زمان آزاد شدن <code class=\"language-text\">std::shared_mutex</code> صبر کنه.</p>\n<p>کتاب مثال خوبی زده که اینجا هم میارم:</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;map></span></span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;string></span></span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;mutex></span></span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;shared_mutex></span></span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">dns_entry</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">dns_cache</span>\n<span class=\"token punctuation\">{</span>\nstd<span class=\"token double-colon punctuation\">::</span>map<span class=\"token operator\">&lt;</span>std<span class=\"token double-colon punctuation\">::</span>string<span class=\"token punctuation\">,</span>dns_entry<span class=\"token operator\">></span> entries<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">mutable</span> std<span class=\"token double-colon punctuation\">::</span>shared_mutex entry_mutex<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n\tdns_entry <span class=\"token function\">find_entry</span><span class=\"token punctuation\">(</span>std<span class=\"token double-colon punctuation\">::</span>string <span class=\"token keyword\">const</span><span class=\"token operator\">&amp;</span> domain<span class=\"token punctuation\">)</span> <span class=\"token keyword\">const</span>\n\t<span class=\"token punctuation\">{</span>\n\t\tstd<span class=\"token double-colon punctuation\">::</span>shared_lock<span class=\"token operator\">&lt;</span>std<span class=\"token double-colon punctuation\">::</span>shared_mutex<span class=\"token operator\">></span> <span class=\"token function\">lk</span><span class=\"token punctuation\">(</span>entry_mutex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\tstd<span class=\"token double-colon punctuation\">::</span>map<span class=\"token operator\">&lt;</span>std<span class=\"token double-colon punctuation\">::</span>string<span class=\"token punctuation\">,</span>dns_entry<span class=\"token operator\">></span><span class=\"token double-colon punctuation\">::</span>const_iterator <span class=\"token keyword\">const</span> it<span class=\"token operator\">=</span>\n\t\tentries<span class=\"token punctuation\">.</span><span class=\"token function\">find</span><span class=\"token punctuation\">(</span>domain<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>it<span class=\"token operator\">==</span>entries<span class=\"token punctuation\">.</span><span class=\"token function\">end</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token operator\">?</span><span class=\"token function\">dns_entry</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span>it<span class=\"token operator\">-></span>second<span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n\t<span class=\"token keyword\">void</span> <span class=\"token function\">update_or_add_entry</span><span class=\"token punctuation\">(</span>std<span class=\"token double-colon punctuation\">::</span>string <span class=\"token keyword\">const</span><span class=\"token operator\">&amp;</span> domain<span class=\"token punctuation\">,</span> dns_entry <span class=\"token keyword\">const</span><span class=\"token operator\">&amp;</span> dns_details<span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">{</span>\n\t\tstd<span class=\"token double-colon punctuation\">::</span>lock_guard<span class=\"token operator\">&lt;</span>std<span class=\"token double-colon punctuation\">::</span>shared_mutex<span class=\"token operator\">></span>entries<span class=\"token punctuation\">[</span>domain<span class=\"token punctuation\">]</span><span class=\"token operator\">=</span>dns_details<span class=\"token punctuation\">;</span>\n\t\t<span class=\"token function\">lk</span><span class=\"token punctuation\">(</span>entry_mutex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h2>پایان</h2>\n<p>خب فصل ۳ کتاب C++ Concurrency in Action هم تموم شد. خیلی خیلی کُند پیش می‌رم. نمیدونم فرصت می‌کنم تا آخر عمرم این کتاب رو تموم کنم یا نه... بهرحال، فصل بعدی درباره «همگام سازی عملیات های همزمان» هست. عزت زیاد (:</p>"}