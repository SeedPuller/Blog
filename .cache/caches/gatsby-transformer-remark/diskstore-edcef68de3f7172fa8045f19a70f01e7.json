{"expireTime":9007200880603432000,"key":"transformer-remark-markdown-html-e29835557d3b91075b3b90a39e1d36b6-gatsby-remark-imagesgatsby-remark-audiogatsby-remark-external-linksgatsby-remark-prismjs-","val":"<p>خب در پست قبل این مسئله که ترد ها برای استفاده از داده باهم مسابقه می‌دن رو کمی بررسی کردیم و یک راه حل دم دست هم براش پیشنهاد دادیم. توی این پست میخوایم در مورد مشکلی بحث کنیم که یجورایی برعکس Race condition هست. توی این مشکل، ترد ها منتظر همدیگه میمونن که از یه داده ای استفاده کنن. انقدر منتظر میمونن که عملا هیچکدومشون کاری دیگه انجام نمیده. به این مشکل چی میگن؟ می‌گن <em>Dead Lock</em>.</p>\n<h2>دِدْلاک(Dead Lock) چیه و چطور حلش کنیم</h2>\n<p>اگه بخوام دقیق‌تر توضیح بدم، فرض کنید دوتا mutex داریم که برای انجام یک عملیات نیازمند این هستیم هر دو این میوتکس ها قفل بشن. حالا فرض کنید که دوتا ترد هم داریم که ترد اولی یکی از اون mutex ها و ترد دوم اون یکی mutex رو قفل کردن. نتیجه این میشه که هر دوی این ترد ها منتظر میمونن تا دومین mutex آزاد بشه تا بتونن قفلش کنن و کار خودشون رو انجام بدن. به این ترتیب هیچکدوم از اونها کاری از پیش نمی‌برن.</p>\n<p>اساسا زمانی که بیشتر از یک mutex رو قفل کنیم، احتمال بوجود اومدن ددلاک وجود داره. یک راهی که پیشنهاد میشه اینه که همیشه یک ترتیب خاصی رو در قفل کردن میوتکس ها حفظ کنیم. اگه همیشه اول mutex A رو قفل کنیم و بعدش mutex B رو قفل کنیم، به ددلاک نمیخوریم. اما باز هم مثل بقیه جاهای زندگی، همه چیز انقدرا هم ساده نیست. فرض کنید یک تابع <code class=\"language-text\">swap(A&amp; a, A&amp;b)</code> داریم که محتویات a و b رو باهم جابجا می‌کنه. همیشه هم داخل این تابع در ابتدا میوتکس مربوط به آرگومان اولی قفل میشه و سپس میوتکس آرگومان دومی قفل میشه. آیا دیگه Dead Lock نخواهیم داشت؟ نخیر! خواهیم داشت. فرض کنید دوتا ترد داشته باشیم که همزمان سعی کنن محتوای دوتا شئ رو باهم عوض کنن؛ فقط با ترتیب برعکس (:</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token function\">swap</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">)</span> <span class=\"token comment\">// thread 1</span>\n<span class=\"token function\">swap</span><span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">)</span> <span class=\"token comment\">// thread 2</span></code></pre></div>\n<p>همین برای یه ددلاک نا زیبا کافیه (:</p>\n<p>خوشبختانه دوستان ما در کتابخانه استاندارد همچین چیزی رو پیش‌بینی کردن و برامون <code class=\"language-text\">std::lock</code> (و در استاندارد ۱۷ به بعد که مورد علاقه من هم هست <code class=\"language-text\">scoped_lock</code>)رو درست کردن. این تابع می‌تونه دوتا ‌میوتکس رو به شکل همزمان قفل کنه و اگه یکی از میوتکس ها آزاد نباشه، بلافاصله اون یکی رو آزاد می‌کنه. یعنی اینطوری که: یا هردو یا هیچکدوم!</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">some_big_object</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">swap</span><span class=\"token punctuation\">(</span>some_big_object<span class=\"token operator\">&amp;</span> lhs<span class=\"token punctuation\">,</span>some_big_object<span class=\"token operator\">&amp;</span> rhs<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">X</span>\n<span class=\"token punctuation\">{</span>\n<span class=\"token keyword\">private</span><span class=\"token operator\">:</span>\n    some_big_object some_detail<span class=\"token punctuation\">;</span>\n    std<span class=\"token double-colon punctuation\">::</span>mutex m<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">public</span><span class=\"token operator\">:</span>\n    <span class=\"token function\">X</span><span class=\"token punctuation\">(</span>some_big_object <span class=\"token keyword\">const</span><span class=\"token operator\">&amp;</span> sd<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span><span class=\"token function\">some_detail</span><span class=\"token punctuation\">(</span>sd<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">friend</span> <span class=\"token keyword\">void</span> <span class=\"token function\">swap</span><span class=\"token punctuation\">(</span>X<span class=\"token operator\">&amp;</span> lhs<span class=\"token punctuation\">,</span> X<span class=\"token operator\">&amp;</span> rhs<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>lhs<span class=\"token operator\">==</span><span class=\"token operator\">&amp;</span>rhs<span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n        std<span class=\"token double-colon punctuation\">::</span><span class=\"token function\">lock</span><span class=\"token punctuation\">(</span>lhs<span class=\"token punctuation\">.</span>m<span class=\"token punctuation\">,</span>rhs<span class=\"token punctuation\">.</span>m<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        std<span class=\"token double-colon punctuation\">::</span>lock_guard<span class=\"token operator\">&lt;</span>std<span class=\"token double-colon punctuation\">::</span>mutex<span class=\"token operator\">></span> <span class=\"token function\">lock_a</span><span class=\"token punctuation\">(</span>lhs<span class=\"token punctuation\">.</span>m<span class=\"token punctuation\">,</span>std<span class=\"token double-colon punctuation\">::</span>adopt_lock<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        std<span class=\"token double-colon punctuation\">::</span>lock_guard<span class=\"token operator\">&lt;</span>std<span class=\"token double-colon punctuation\">::</span>mutex<span class=\"token operator\">></span> <span class=\"token function\">lock_b</span><span class=\"token punctuation\">(</span>rhs<span class=\"token punctuation\">.</span>m<span class=\"token punctuation\">,</span>std<span class=\"token double-colon punctuation\">::</span>adopt_lock<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">// 3 lines above could brief in: scoped_lock(lhs.m, rhs.m)</span>\n        <span class=\"token function\">swap</span><span class=\"token punctuation\">(</span>lhs<span class=\"token punctuation\">.</span>some_detail<span class=\"token punctuation\">,</span>rhs<span class=\"token punctuation\">.</span>some_detail<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h2>راه های دیگه</h2>\n<h3>از قفل کردن های تو در تو بپرهیزید</h3>\n<p>مسئله ساده‌ست. اول اینکه سعی کنید تا جای ممکن بیشتر از یدونه mutex رو قفل نکنید. اگر مجبور بودیم، حداقل میوتکس ها رو به صورت همزمان- حالا با استفاده از <code class=\"language-text\">std::lock</code> یا <code class=\"language-text\">std::scoped_lock</code>)- قفل کنید.</p>\n<h3>قفل کردن با ترتیب معین و مشخص</h3>\n<p>قبل تر هم گفتم، اگه با ترتیب خاصی این قفل کردن رو انجام بدیم با تقریب خوبی زیاد به مشکل نمی‌خوریم. اگه مجبوریم دوتا میوتکس رو جدا جدا قفل کنیم، بهتره که ترتیبشون رو در همه جا رعایت بکنیم. ولی خب اینکار هم نیازمند مراقبت های دیگه‌ست. به عنوان مثال یک لیست دو پیوندی رو در نظر بگیرید. برای پیمایش این  لیست ما میایم و هر گره ای که میخوایم بخونیم رو قفل می‌کنیم و برای حرکت کردن هم میایم گره بعدی/قبلی رو قفل می‌کنیم و گره فعلی رو آزاد می‌کنیم. اینجا هم مشکل هست. اگر دوتا ترد به شکل همزمان ولی با جهت عکس همدیگه(یعنی یکی از اول لیست بره آخر و اون یکی برعکس) شروع به پیمایش لیست بکنن، در وسط لیست به dead lock میخورن. راه حل اینه که یک محدودیت اضافی بذاریم که فقط یکی از نحوات پیمایش کردن مجاز باشه :) پس باید حواسمون به خیلی چیزا باشه.</p>\n<p><img src=\"https://mark.nl.tab.digital/s/Ejd85qkYcKAAP84/preview\" alt=\"picture\">{: .normal }\n<em>اگه در این وضعیت دوتا ترد مخالف جهت همدیگه شروع به حرکتت کنن،‌ ددلاک خواهیم داشت</em></p>\n<h3>استفاده از قفل های سلسله‌مراتبی</h3>\n<p>ایده کلی‌ش تقریبا همون راه قبلیه فقط با این تفاوت که میایم و یک Lock hierarchy درست می‌کنیم که بیاد در runtime چک کنه که آیا ترتیب قفل شدن میوتکس ها صحیحه یا نه. اینطوری کمتر نیاز داریم که «خودمون حواسمون جمع باشه که ترتیب رو رعایت کنیم».</p>\n<p>حالا این ایده چطوری کار می‌کنه؟ اینطوری که میایم و برنامه‌مون رو به لایه های مختلف تقسیم می‌کنیم و مشخص می‌کنیم که هر میوتکس مربوط به کدوم لایه‌ست. قانون قفل کردن رو هم اینطوری قرار می‌دیم که فقط از بالا به پایین امکان قفل کردن وجود داشته باشه. یعنی اگر فرض کنیم لایه ۱ بالای لایه ۲ و لایه ۲ هم بالای لایهٔ ۳ قرار داشته باشه و الی آخر، فقط تنها زمانی می‌تونیم مثلا لایه ۲ رو قفل کنیم که لایه های پایین ترش آزاد باشن. بنابراین فقط می‌تونیم از بالا به پایین حرکت کنیم.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\">hierarchical_mutex <span class=\"token function\">high_level_mutex</span><span class=\"token punctuation\">(</span><span class=\"token number\">10000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nhierarchical_mutex <span class=\"token function\">low_level_mutex</span><span class=\"token punctuation\">(</span><span class=\"token number\">5000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nhierarchical_mutex <span class=\"token function\">other_mutex</span><span class=\"token punctuation\">(</span><span class=\"token number\">6000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">do_low_level_stuff</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">low_level_func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n\tstd<span class=\"token double-colon punctuation\">::</span>lock_guard<span class=\"token operator\">&lt;</span>hierarchical_mutex<span class=\"token operator\">></span> <span class=\"token function\">lk</span><span class=\"token punctuation\">(</span>low_level_mutex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">return</span> <span class=\"token function\">do_low_level_stuff</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">high_level_stuff</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> some_param<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">high_level_func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n\tstd<span class=\"token double-colon punctuation\">::</span>lock_guard<span class=\"token operator\">&lt;</span>hierarchical_mutex<span class=\"token operator\">></span> <span class=\"token function\">lk</span><span class=\"token punctuation\">(</span>high_level_mutex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token function\">high_level_stuff</span><span class=\"token punctuation\">(</span><span class=\"token function\">low_level_func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">thread_a</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n\t<span class=\"token function\">high_level_func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">do_other_stuff</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">other_stuff</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n\t<span class=\"token function\">high_level_func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token function\">do_other_stuff</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">thread_b</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n\tstd<span class=\"token double-colon punctuation\">::</span>lock_guard<span class=\"token operator\">&lt;</span>hierarchical_mutex<span class=\"token operator\">></span> <span class=\"token function\">lk</span><span class=\"token punctuation\">(</span>other_mutex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token function\">other_stuff</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>کد بالا نمونه استفاده از یک میوتکس سلسله مراتبی یا hierarchical mutex هست. ترد a بدون مشکل می‌تونه به کارش ادامه بده چون میوتکس هاش رو با رعایت قوانین(که بالاتر ذکر کردم) قفل می‌کنه. اما ترد b به مشکل میخوره. چرا؟ چون اول اومده <code class=\"language-text\">other_mutex</code> که عددش برابر با 6000 هست رو قفل کرده. بعدش چی؟ بعدش در تابع <code class=\"language-text\">other_stuff()</code> اومده و یک میوتکس با عدد 10000 رو قفل کرده. و این مشخصا خلاف قوانینی که گفتیمه چرا که ترد ها فقط میتونن ترد هایی با عدد کمتر از عدد فعلی رو قفل کنن و برعکسش امکان پذیر نیست. به همین شکل، ترتیب قفل کردن ترد ها رعایت می‌شه (: </p>\n<p>البته این روش هم مشکلاتی داره... به عنوان مثال برای پیمایش یک لیست که نیازمند دست به دست کردن یا hand-over-hand کردن قفلِ میوتکس ها هست، جواب نمیده برای اینکه اونوقت به تعداد گره های لیست نیاز به سطح/لایه/... داریم! :/</p>\n<h2>Storage class specifier: <code class=\"language-text\">thread_local</code></h2>\n<p>اگه بخوایم یه متغییری داشته باشیم که به ازای هر «ترد» ازش ساخته بشه، از این مشخصه استفاده می‌کنیم.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">thread_local</span> <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">int</span> value <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> </code></pre></div>\n<p>فرض کنیم دو ترد به اسم a و b داریم. اگر مقدار <code class=\"language-text\">value</code> در ترد a برابر با ۲ بشه، همه اونهایی که در ترد a هستن مقدار ۲ رو می‌بینن ولی مقدار <code class=\"language-text\">value</code> در ترد b همون ۱ هست و تغییری نمی‌کنه. بنابراین، این نوع متغییر ها فقط به ازای هر ترد براشون حافظه تخصیص داده می‌شه و در پایان کار هر ترد هم از بین می‌رن.</p>\n<h2>پایان</h2>\n<p>بحث دِدلاک هم تقریبا فهمیدیم چیه و چطور میشه ازش جلوگیری کرد. متاسفانه دوباره دارم برمیگردم به اون حالت هیچکاری نکردن و عقب موندن از همه کارهام. از این وضعیت خوشم نمیاد. سعی می‌کنم تغییرش بدم.</p>\n<p>در پست بعدی درباره اینکه چطور با میوتکس ها می‌تونیم ژانگولر بازی در بیاریم صحبت می‌کنیم.</p>"}