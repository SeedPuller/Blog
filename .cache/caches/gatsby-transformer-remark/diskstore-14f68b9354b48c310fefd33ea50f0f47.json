{"expireTime":9007200880603432000,"key":"transformer-remark-markdown-html-4b36e05a8a560c45ac019c4398d9796c-gatsby-remark-imagesgatsby-remark-audiogatsby-remark-external-linksgatsby-remark-prismjs-","val":"<p>بالاخره شروع کردم به خوندن کتاب C++ Concurrency in action نوشته\nAnthony Williams. این کتاب رو باید یک ماه پیش تموم می‌کردم اما مثل همیشه\nخیلی کند پیش رفتم و فقط ۲ فصلش رو تا الآن خوندم و تازه دارم خلاصه فصل\nاول رو می‌نویسم. به خودم قول دادم که توی این هفته این کتابو تموم کنم و <strong>باید انجامش بدم</strong>.</p>\n<p>این کتاب درباره همزمانی در سی++ عه و راجع به نحوه نوشتن برنامه های\nاین چنینی و چالش های پیش رو و راه های مرسوم برای حل چالش ها صحبت می‌کنه.\nیجورایی معروف ترین کتاب در این زمینه‌ست و خود نویسنده‌ش در کمیته\nاستاندارد سی++ در همین بخش کار می‌کنه و پروپوزال میده.</p>\n<p>با اینکه کتاب از مفاهیم پایه شروع به توضیح کرده، به نظرم بهتره آدم\nقبلش معماری کامپیوتر بدونه تا خیلی راحت تر بفهمه که چی به چیه.</p>\n<h2>همزمانی(Concurrency) چیست؟</h2>\n<p>همزمانی درواقع به معنی انجام دادن چندکار در یک زمان واحده. به عنوان\nمثال میشه به وقتی که داریم راه می‌ریم و همزمان تلفن رو با دستمون نگه\nداشتیم و داریم چت می‌کنیم اشاره کرد. اینکار هارو به شکل همزمان انجام\nمی‌دیم.</p>\n<h2>همزمانی در کامپیوتر</h2>\n<p>همونطور که می‌دونیم، کامپیوتر ها در حالت عادی کار هارو به شکل ترتیبی از دستورات پشت سر هم انجام می‌دن. </p>\n<p>وقتی از همزمانی در کامپیوتر صحبت می‌کنیم یعنی یک سیستم چندین کار رو\nبه شکل همزمان و موازی انجام بده. حالا میخواد از طریق Task switching باشه\nیا به معنای واقعی کلمه همزمان باشه.</p>\n<p>همزمانی از زمان های خیلی قدیم تر هم بوده. از سیستم عامل های Multi\ntask که میتونستن چندکار رو با استفاده از task switching انجام بدن گرفته\nتا سرورهایی که چندین پردازنده داشتن و رسما به شکل موازی کار هارو انجام\nمی‌دادن. اما در دنیای امروز، استفاده از سیستم هایی که به شکل سخت افزاری\nمیتونن وظایف رو به شکل همزمان انجام بدن بسیار بسیار بیشتر شده و به همین\nدلیله که همه باید بلد باشیم چطور باید با این کامپیوتر ها کار کرد.</p>\n<p>همونطور که گفتم، قبلا کامپیوتر ها کلا از دو روش برای انجام همزمان کارها استفاده می‌کردن: </p>\n<h3>جابجایی بین وظایف(task switching)</h3>\n<p>کامپیوتر هایی که یک پردازنده داشتن، از لحاظ تئوری امکان اینکه چند کار\nرو به شکل همزمان انجام بدن وجود نداشت. پس چطور اینکار رو انجام می‌دادن؟</p>\n<p>با تقسیم کردن وظایف به چند قسمت و انجام دادن یه تیکه از هر وظیفه.\nیعنی چی؟ یعنی پردازنده در ثانیه بین وظایف مختلف پرش انجام میده و هربار\nیکم از کار هرکدوم رو انجام می‌ده. اینکار انقدر سریعه که انگار برنامه ها\nدارن باهمدیگه اجرا می‌شن و یجور <strong>توهم همزمانی</strong> رو ایجاد میکنه.</p>\n<h3>همزمانی سخت افزاری(hardware concurrency)</h3>\n<p>کامپیوتر هایی که چند پردازنده دارن یا اونایی که یک پردازنده چند هسته ای دارن میتونن واقعا کارها رو به شکل همزمان انجام بدن</p>\n<p>درحالت کلی، task switching بسیار کُند تر از همزمانی سخت افزاریه چرا که در حالت اول، پردازنده باید فرآیندی رو به نام <em>context sw</em>itch\nرو انجام بده. خلاصه‌ش اینه که وقتی میخواد از یک کاری به کار دیگه پرش\nانجام بده، باید state ای که cpu داره رو ذخیره کنه و همچنین اشاره گر به\nدستوری که میخواسته اجرا کنه رو هم ذخیره کنه. بعد به کار بعدی پرش انجام\nبده و اونجا state مربوط به اون وظیفه رو بازیابی کنه، دستورات موجود در\nحافظه رو بارگزاری کنه تا بتونه شروع به پردازش اون وظیفه کنه. همه اینکار\nها باعث میشن که تاخیر بیشتری در انجام کارها صورت بگیره. تصویر زیر کاملا\nاین مطلب رو روشن می‌کنه. دو task داریم که هرکدوم به ۱۰ قسمت تقسیم\nشده‌ن(یک task با رنگ قرمز و دیگری سبز).</p>\n<p><img src=\"https://mark.nl.tab.digital/s/JQTsQntcTBLrRig/preview\" alt=\"picture\">{: .normal}\n<em>مقایسه اجرای دو کار روی یک پردازنده تک هسته ای و یک پردازنده دو هسته ای</em></p>\n<h2>رویکرد های همزمانی</h2>\n<p>اساسا از دو چیز برای پیاده سازی همزمانی استفاده میشه: </p>\n<ul>\n<li>ترد ها/ نخ ها/ threads</li>\n<li>پروسه ها/ پردازه ها/ processes</li>\n</ul>\n<p>دو کارمند رو تصور کنید که میخوان در یک شرکت روی یک پروژه کار کنن.\nایده اول اینه که به هرکدوم یک اتاق جدا بدیم و همچنین یک کپی از راهنمای\nنرم افزاری که میخوان روش کار کنن هم به هرکدوم بدیم. چالش هایی که\nروبه‌رومونه ایناست:</p>\n<ul>\n<li>باید دوتا اتاق رو مدیریت کنیم</li>\n<li>دوتا کارمند برای صحبت کردن با همدیگه مجبورن از جاشون بلند شن و برن پیش همدیگه</li>\n<li>از هر چیزی باید دوتا کپی بگیریم و بهشون بدیم</li>\n</ul>\n<p>ایده دوم اینه که هردو نفر رو در یک اتاق بذاریم و اینطوری کافیه یه کپی از راهنمای نرم افزار رو بهشون بدیم. فرق این روش چیه؟</p>\n<ul>\n<li>تمرکز کردن احتمالا براشون سخت تر میشه</li>\n<li>نیاز نیست که چندین\nکپی از منابع بگیریم اما ممکنه هردوتاشون به یک چیز ثابت نیاز داشته باشن و\nاینطوری باید صبر کنن تا کار شخص دیگر تموم بشه.</li>\n<li>میتونن به راحتی با هم صحبت کنن و ایده هاشون رو به اشتراک بذارن.</li>\n</ul>\n<p>با استفاده از این مثال میتونیم دو رویکرد اساسی رو بررسی کنیم.</p>\n<p>کارمند هارو به عنوان ترد ها و اتاق هارو به عنوان پروسه ها در نظر می‌گیریم. </p>\n<p>بنابراین دو رویکرد ما به این صورت خواهند بود:</p>\n<ul>\n<li>چند پروسه تک-نخی</li>\n<li>یک پروسه چند-نخی</li>\n</ul>\n<h4>چند پروسه تک-نخی</h4>\n<p><img src=\"https://seedpuller.space/wp-content/uploads/2020/09/image-2.png\"></p>\n<p>دو پروسه صرفا با استفاده از IPC میتونن باهم ارتباط برقرار کنن و این\nباعث میشه سرعت اجرای کارها پایین بیاد چرا که سیستم عامل لایه های محافظتی\nای رو اعمال می‌کنه که یک پروسه نتونه داده های پروسه های دیگه رو ویرایش\nکنه یا به راحتی بخونه.</p>\n<p>از طرف دیگه اجرای پروسه های زمان بیشتری نیاز داره.</p>\n<p>اما خوبی هایی هم داره: اضافه شدن لایه های انتزاعی کمک میکنه که نیاز\nنباشه برنامه پیچیده ای برای ارتباط نوشته بشه و بیشتر کار رو خود سیستم\nعامل انجام میده و همچنین، این قابلیت ایجاد میشه که یک وظیفه رو بین <strong>چند کامپیوتر‌</strong> در شبکه تقسیم کرد.</p>\n<h4>یک پروسه چند-نخی</h4>\n<p><img src=\"https://seedpuller.space/wp-content/uploads/2020/09/image-3.png\"></p>\n<p>رویکرد دیگه ای که ازش استفاده می‌شه، نوشتن یک برنامه چند نخی‌ست.</p>\n<p>ترد ها یجورایی همون ساده شدهٔ پروسه ها هستن. یک پروسه میتونه از چندین\nترد تشکیل بشه و بیشتر اطلاعات میتونن از طریق حافظه به اشتراک گذاری شده\n(shared memory) بین ترد ها جابجا بشن. ترد ها دیگه اون سربار مربوط به\nمحافظت های سیستم عامل رو ندارن به همین دلیل سریعترن و درواقع اکثر برنامه\nنویس ها از این روش برای پیاده سازی همزمانی استفاده می‌کنن.</p>\n<p>خود سی++ هم راهکار خاصی برای پیاده سازی رویکرد «پروسه های تک-نخی» نداره و برای پیاده سازیش باید به API های سیستم متکی بود.</p>\n<p>اما ترد ها یه مشکلی دارن و اونم اینه که باید مطمئن بشیم اون دادهٔ اشتراکی که چند ترد میخوان بخوننش، برای همه ثابت باشه. </p>\n<p>راهکار های بسیاری برای حل این مشکل وجود داره که بسته به سناریو میشه ازشون استفاده کرد و این چالش رو هم حل کرد.</p>\n<h2>تفاوت همزمانی با موازی کاری(Concurrency vs. Parallelism)</h2>\n<p>یکی از کلماتی که در حوزه برنامه نویسی چند نخی شنیده میشه، موازی کاری یا parallelism است.</p>\n<p>این دو مفهوم همپوشانی بسیار زیادی باهم دارن اما با هم متفاوتن. </p>\n<p>در حالت کلی هردو مفهوم درباره اجرا کردن چند وظیفه به شکل همزمان و موازی هستن اما هدف‌شون فرق می‌کنه.</p>\n<p>هدف موازی‌کاری، <strong>افزایش کارایی و performance</strong> هست. اینکه سریعتر یک سری پردازش روی داده ها انجام بشه.</p>\n<p>هدف همزمانی، جدا کردن بخش های مختلف برنامه یا به عبارت دیگه <em><strong>Separation of Concerns</strong></em> هست.</p>\n<h2>همزمانی برای جدا کردن بخش های مختلف</h2>\n<p>اینکه ما بتونیم بخش هایی که به همدیگه مربوطن رو نزدیک هم نگه داریم و\nبخش هایی که ربطی به همدیگه ندارن رو از هم دور کنیم باعث میشه مدیریت کردن\nکد و برنامه راحت تر بشه و بخش های مختلف برنامه جدا از همدیگه [و به صورت\nموازی] کار کنن. </p>\n<p>به عنوان مثال یک برنامه DVD Player رو در نظر می‌گیریم. این برنامه چندین کار رو همزمان باید انجام بده:</p>\n<ul>\n<li>دیکد کردن فایل ویدئویی</li>\n<li>پخش کردن تصویر</li>\n<li>پخش کردن صدا</li>\n<li>ارتباط با کاربر(مثلا برای متوقف کردن پخش)</li>\n</ul>\n<p>بدون استفاده از همزمانی، این کار ها نمیتونن به شکل همزمان باهمدیگه انجام بشن (:</p>\n<h2>همزمانی برای افزایش کارایی</h2>\n<p>این رویکرد، برای کاهش زمان اجرای الگوریتم بکار می‌ره و دو روش اصلی اون عبارت اند از:</p>\n<ul>\n<li>یک کار ثابت رو به چند قسمت تقسیم کنیم و هر قسمت به شکل موازی\nباهمدیگه انجام بشن. درواقع به این معنیه که هر ترد یک بخشی از الگوریتم رو\nانجام بده. به این میگن <em>Task parallelism</em></li>\n<li>یک داده رو به چند قسمت تقسیم کنیم و یک کار ثابت رو روی قسمت های مختلف داده ها انجام بدیم. به این روش میگن <em>Data Parallelism</em></li>\n</ul>\n<h3>الگوریتم های موازی</h3>\n<p>به الگوریتم هایی که به راحتی میتونن به شکل موازی اجرا بشن اصطلاحا می‌گن این الگوریتم به شکل خجالت آوری قابل موازی شدنه =)</p>\n<p>الگوریتم های embarrassingly parallel این قابلیت رو دارن که به راحتی\nبه چندین قسمت تقسیم بشن و به شکل موازی به سرانجام برسن. همچنین قابلیت\nمقیاس پذیری دارن یعنی میشه تعداد قسمت هارو به راحتی تغییر داد.</p>\n<h2>پایان</h2>\n<p>خیلی موضوع جالبیه و نیازمند مطالعه بسیار. توی کتاب معماری کامپیوتر\nپترسون هم بهش رسیدم و امیدوارم بتونم وقتمو طوری تنظیم کنم که اونو هم\nبخونم(خیلی تنبلم). </p>\n<p>احتمالا فقط خلاصه بخش هایی رو می‌نویسم که مفهومی ان و راجع به بخش هایی که بیشتر کد نویسی ان چیزی نمی‌نویسم.</p>\n<p>خیلی از بخش های آخر(مثل: «چه زمانی نباید از همزمانی استفاده کنیم؟»)  رو ننوشتم بخاطر اینکه فکر نمی‌کنم فراموشم بشن </p>"}