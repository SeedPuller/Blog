{"expireTime":9007200880603433000,"key":"transformer-remark-markdown-html-41b432ade89f203afb89bae8978c887a-gatsby-remark-imagesgatsby-remark-audiogatsby-remark-external-linksgatsby-remark-prismjs-","val":"<p>بعد از چندروز دعوا با سگ وحشی افسردگی دوباره امروز تونستم یکم به\nمطالعه‌م برسم. درواقع علاوه بر یادگیری، اینکه بخوام سریعتر توی وبلاگم\nدربارش بنویسم هم بهم انگیزه داد</p>\n<p>درواقع این پست حاصل یادگیری امروزم نیست و تقریبا یه هفته‌ست که روی\nاین بخش گیر کردم. گاهی وقتا آدم سنگین تر از اونه که بخواد کاری انجام\nبده. اما بهرحال اینجاییم و داریم پیش میریم، هرچقدر هم که بخواد کًند باشه</p>\n<p>پًست امروز درباره‌ی Pipeline Processing عه و احتمالا پست بعدی هم درباره همین مورد باشه.</p>\n<p>پردازش خط لوله‌ای(pipeline processing) یه تکنیکه که طی اون زیرعمل\nها(sub operation) و یا بخش های مختلف از یک سیکل دستور، با همدیگه\nهمپوشانی(overlap) پیدا میکنن.</p>\n<p>این روش برای انجام کارها با تکرار زیاد بسیار مناسبه و نیازمند این هست\nکه CPU چند فانکشنال یونیت مجزا داشته باشه که به صورت موازی کار انجام\nبدن. </p>\n<p>دو بحش هست که پایپلاین داخلشون استفاده میشه یکیش arithmetic pipeline\n(عملیات های مختلف ریاضی رو به سگمنت های جدا تبدیل میکنه) و اون یکی هم\ninstruction pipeline (بخش های مختلف مثل fetch و decode و execution رو به\nسگمنت های مختلف تبدیل میکنه)</p>\n<p>معمولا بعد از هر سگمنت یک pipeline register وجود داره که نتیجه‌ی حاصل\nشده از کار سگمنت قبل از خودش ذخیره می‌کنه و در اختیار سگمنت بعدی\nمیذاره.(درواقع بین دو سگمنت A و B یک رجیستر وجود داره که به عنوان خروجی A\nو ورودی B میتونه محسوب بشه)</p>\n<h2>Arithmetic Pipeline</h2>\n<p>معمولا این پایپلاین برای انجام عملیات ها روی اعداد اعشاری و ضرب برای\nاعداد غیر اعشاری انجام میشه. توضیحاتش به نظرم بدیهی اومد بنابراین\nنمی‌نویسمش.</p>\n<h2>Instruction Pipeline</h2>\n<p>همون طور که عمل پایپلاینینگ میتونه روی data stream ها انجام بشه،\nمیتونه روی instruction stream هم انجام بشه. همونطور که میدونیم اجرای یه\nدستور از چند بخش تشکیل شده:</p>\n<ul>\n<li>fetch</li>\n<li>decode</li>\n<li>محاسبه effective address </li>\n<li>دریافت operand ها(fetch operand)</li>\n<li>اجرا(execute) </li>\n<li>write back</li>\n</ul>\n<p>ما برای بررسی راحت تر چندتا از این بخش هارو باهم یکی می‌کنیم و فرض می‌کنیم مراحل اجرای یک دستور صرفا شامل مراحل زیر هست:</p>\n<ul>\n<li>fetch (FI)</li>\n<li>decode (DA)</li>\n<li>fetch operand (FO)</li>\n<li>execute (EX)</li>\n</ul>\n<p>مثال ما ۴ استیج(سگمنت) هست اما توی کامپیوتر های دیگه تعداد استیج ها متفاوته(مثلا توی پنتیوم ۴ اینتل حدود ۳۰ تا استیج داریم).</p>\n<p>توی جدول زیر میتونیم ببینیم که چطور بخش های مختلف باهم دیگه overlap\nپیدا می‌کنن. محور عمودی دستورات هستند و محور افقی کلاک ها هستن.<img src=\"https://seedpuller.space/wp-content/uploads/2020/04/image.png\"></p>\n<h3>مشکلات instruction pipeline</h3>\n<ul>\n<li>resource conflict ها</li>\n<li>Data dependency ها</li>\n<li>Branch difficulty ها</li>\n</ul>\n<h2>Resource Conflict</h2>\n<p>این مشکل زمانی رخ میده که دوتا سگمنت به صورت همزمان بخوان به مموری\nدسترسی داشته باشن. اینطور که کتاب گفته این مشکل معمولا با جدا کردن حافظه\nدیتا و اینستراکشن ها رفع میشه. اما خب این واسه کامپیوتر های خیلی\nقدیمیه، باید بگردم ببینم توی کامپیوتر های جدید این موضوع چطوریه.</p>\n<h2>Data Dependency</h2>\n<p>مشکل data dependency و address dependency که باعث کاهش پرفورمنس هم\nمیشن، وقتی به وجود میان که یک سگمنت به یک داده و یا آدرسی نیاز داشته\nباشه که هنوز در دسترسش نیست. مثال: مثلا دستور A یک داده ای رو به عنوان\nخروجی تولید میکنه که این داده قراره به عنوان operand توی دستور B استفاده\nبشه. این دوتا دستور متوالی هستند،  حالا قسمت Fetch operand(که میخواد\nاوپرند های دستور B رو لود کنه) تا زمانی که بخش Execute (که داره دستور A\nرو اجرا می‌کنه) تموم نشه نمیتونه داده های مورد نیاز خودش رو بدست بیاره.\nپس باید صبر کنه تا اجرای دستور قبلی به اتمام برسه تا کارش رو انجام بده.\nهمین اتفاق برای آدرس ها هم میوفته. یعنی یک سگمنت به آدرسی نیاز داره که\nهنوز دستور قبلی تولیدش نکرده.</p>\n<p>برای حل این مشکل معمولا سه تا راه وجود داره:</p>\n<h4>Hardware interlock</h4>\n<p>با اضافه کردن interlock، این مدار هروقت تشخیص بده که خروجی دستور فعلی\nقراره به عنوان ورودی دستور بعدی استفاده بشه، با استفاده از کلاک های\nاضافه تاخیر ایجاد میکنه تا اجرای دستور فعلی تموم بشه.</p>\n<h4>Operand forwarding</h4>\n<p>این راه حل اینطوریه که با استفاده از یه سری سخت افزارای خاص میان بین\nسگمنت های مختلف مسیر های جداگونه میسازن. یعنی چی؟ اینطوریه که به عنوان\nمثال اگر قرار باشه خروجی دستور A از ALU توی یک رجیستر خاص قرار بگیره،\nاین مدار چک میکنه که آیا این رجیستر به عنوان ورودی دستور بعدی میخواد\nاستفاده بشه؟ اگر جواب بله بود، به جای اینکه دیتا رو از ALU به رجیستر\nمنتقل کنه و دستور بعدی با مراجعه به رجیستر اطلاعات موردنیاز خودش رو\nدریافت کنه، دیتا رو مستقیما به ورودی های ALU میفرسته تا برای دستور بعدی\nاستفاده بشن.</p>\n<h4>Delayed load</h4>\n<p>توی این روش، حل این مشکل رو به عهده‌ی کامپایلری میذاریم که داره زبان\nسطح بالا رو به زبان سطح پایین تبدیل میکنه. درواقع کامپایلر وقتی data\nconflict رو میبینه، سعی میکنه با تغییر دادن ترتیب دستور ها(مثلا با اضافه\nکردن nop) به قدر کافی برای اجرا شدن دستور قبلی زمان ایجاد بکنه.</p>\n<h2>Branch difficulty</h2>\n<p>این مشکل درواقع یک چالش برای مدیریت کردن branch های رخ داده توی\nبرنامه‌ست. همونطور که میدونیم branch ها جریان عادی دستورات برنامه رو\nمیشکنن. چالش اینه که چطور conditional branch و unconditional branch رو\nمدیریت کنیم که کمترین ضرر رو به پرفورمنس بزنیم.</p>\n<h4>Prefetch target instruction</h4>\n<p>این یکی از راه حل های موجود برای مدیریت کردن conditional branch هاست.\nنحوه‌ی کارش اینطوریه که هردوحالت (اجرا شدن branch و اجرا نشدنش) رو\nدرنظر میگیره. یعنی چی؟ یعنی شروع میکنه دستوراتی که در صورت وقوع branch\nقراره اجرا بشن و به صورت همزمان دستوراتی که در صورت انجام نشدن branch\nقراره اجرا بشن رو fetch می‌کنه. اگر شرط مربوط به branch درست بود، میره و\nدستورات branch رو(که قبلا fetch کرده) اجرا میکنه. در غیر این صورت\nدستورات مربوط به جریان عادی برنامه رو اجرا می‌کنه.</p>\n<h4>Branch Target Buffer(BTB)</h4>\n<p>BTB یه حافظه کوچیکه که توی استیج fetch قرار می‌گیره.کارش اینه که آدرس\nچند branch اجرا شده‌ی اخیر + آدرس target اونها + چندتا از instruction\nهای بعد از target رو داخل خودش ذخیره میکنه. وقتی دستور توی پایپلاین\nرمزگشایی دیکد میشه، توی BTB میگرده که آیا آدرس این دستور(که یه branch\nهست) توی BTB وجود داره یا نه. اگه وجود داشته باشه، اون دستور و\nمتعلقاتش(مثل آدرس تارگت و چندتا دستور اولِ اون branch) مستقیما در دسترس\nهستند و دستورات از مسیر جدید به سرعت fetch میشن. اگه آدرس جستجو شده توی\nBTB وجود نداشته باشه، این دستور به علاوه‌ی متعلقاتش توی BTB ذخیره میشن و\nپایپلاین خالی میشه تا مسیر جدید دستور ها توی پایپلاین قرار بگیره.</p>\n<h4>Loop buffer</h4>\n<p>یکی از انواع BTB عه که شامل یه رجیستر فایل بسیار سریعه و توسط بخش\nfetch مدیریت میشه. وقتی مشخص میشه قراره یه حلقه اجرا بشه، کل محتویات اون\nحلقه داخل این بافر ذخیره میشه و بنابراین برای اجرای دستورات داخل حلقه\nنیازی به رجوع به حافظه نیست.</p>\n<p>دستورات داخل حلقه تا پایان اجرای حلقه داخل این بافر میمونن.</p>\n<h4>Branch Prediction</h4>\n<p>یکی از بحث های خفن معماری کامپیوتره که خیلی درباره‌ش بحث میشه. توی\nاین کتاب تا اینجا توضیح مختصری داده اما با جستجویی که خودم کردم مثل\nاینکه موضوع خیلی بحث برانگیز و جالبیه.</p>\n<p>branch prediction درواقع فرآیندیه که طی اون پایپلاین سعی میکنه قبل از\nاجرا شدن یه conditional branch حدس بزنه که آیا شرط (condition) صدق\nخواهد کرد یا نه. در صورتی که پیشبینی کنه این شرط درست خواهد شد، شروع\nمیکنه دستوراتِ داخل branch رو fetch میکنه. اگر پیشبینی درست باشه،‌ دیگه\nوقفه ای در کار پایپلاین رخ نمی‌ده.</p>\n<h2>در آخر</h2>\n<p>برای اینکه این پست طولانی نشه، ادامه‌ی مطالب این پست رو توی پست بعدی می‌نویسم که اون هم درباره‌ی پردازش موازیه</p>"}