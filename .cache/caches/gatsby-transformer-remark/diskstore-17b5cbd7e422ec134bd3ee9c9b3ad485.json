{"expireTime":9007200880603433000,"key":"transformer-remark-markdown-html-3ab1e452a12b29b4fdfd7a3877e94ba7-gatsby-remark-imagesgatsby-remark-audiogatsby-remark-external-linksgatsby-remark-prismjs-","val":"<p>خب دیروز نشد که پست معماری کامپیوتر رو بنویسم. امروز سعی می‌کنم دوتا پست راجع به معماری کامپیوتر موریس مانو بنویسم. </p>\n<p>این پست درباره‌ی تفاوت های ساده‌ی معماری سیسک و ریسک هست.</p>\n<p>در حالت خیلی ساده به کامپیوتر هایی که تعداد زیادی دستورات پیچیده دارن میگن Complex Instruction Set Computer یا CISC.</p>\n<p>ایده‌ی RISC از اینجا اومد که اوایل دهه هشتاد یه سری طراحای کامپیوتر\nاومدن گفتن بیاین کامپیوتری داشته باشیم که تعداد دستورات کمتر و با ساختار\nساده تری داشته باشه. پس اسم این سری کامپیوتر هارو گذاشتن Reduced\nInstruction Set Computer یا RISC.</p>\n<h2>معماری CISC</h2>\n<p>یکی از اهداف این معماری، ساده کردن کامپایل از زبان های سطح بالا به زبان ماشینه. بنابراین این معماری تعداد دستورات زیادی داره. </p>\n<p>درواقع سعی شده statement هایی که به زبان های سطح بالا نوشته میشن یه معادل مستقیم توی دستوراتِ این معماری داشته باشند.</p>\n<p>یکی دیگه از ویژگی های این معماری، variable-length بودن قالب\nدستوراتشه. یعنی دستورات طول یکسانی ندارند(طول دستورات یعنی معادل باینری\nیک instruction)؛ یک دستور ممکنه ۵ بایت جا بگیره و یک دستور دیگه ممکنه ۲\nبایت جا بگیره. بنابراین به عنوان مثال در یک سیستم با کلمه های ۳۲ بیتی\n(32bit words) یک دستور ممکنه نصف یک کلمه جا بگیره و دستور دیگه ممکنه یک\nکلمه به علاوه‌ی یک بایت از کلمه‌ی بعدی رو اشغال کنه. در این معماری یک\nبار باید عمل decode برای مشخص کردن طول دستور انجام بشه و یکبار هم برای\nپردازشِ خودِ دستور(مثل مشخص کردن opcode و …).</p>\n<p>خلاصه ویژگی های این معماری به این صورته:</p>\n<ul>\n<li>تعداد دستورات زیاد</li>\n<li>مد های آدرس دهی بسیار وسیع</li>\n<li>variable-length بودن دستور ها</li>\n<li>امکان manipulate کردن مستقیم در مموری فراهمه</li>\n</ul>\n<h2>معماری RISC</h2>\n<p>این معماری بیشتر روی ساده تر بودن دستورات تاکید داره</p>\n<p>ویژگی های این معماری به این صورته:</p>\n<ul>\n<li>تعداد دستورات نسبتا کمی داره</li>\n<li>تعداد مد های آدرس‌دهی نسبتا کمی داره</li>\n<li>دستورات توی یک سیکل اجرا میشن</li>\n<li>طول دستورات یکسانه</li>\n<li>تعداد رجیسترهای بیشتری داره</li>\n<li>مثل اینکه پایپلاین ها موثر تر هستن(چراش رو نمیدونم)</li>\n</ul>\n<p>ثابت بودن طول دستور ها این امکان رو فراهم میکنه که کدگشایی دستورات\nخیلی راحت تر و سریعتر صورت بگیره و از اونجایی که دسترسی به حافظه محدوده،\nپردازش ها در رجیستر ها انجام میشن(که خیلی سریعتر از حافظه‌ست) و صرفا از\nحافظه برای دریافت operand ها و یا قرار دادن نتایج استفاده میشه.</p>\n<h2>در آخر</h2>\n<p>حجم کدها توی ریسک بیشتر از سیسکه، کمتر از حافظه و بیشتر از رجیستر ها استفاده میشه و مصرف حافظه کمتر و سرعت بالاتری داره.</p>"}