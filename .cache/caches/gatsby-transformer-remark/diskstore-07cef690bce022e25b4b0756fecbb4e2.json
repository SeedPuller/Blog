{"expireTime":9007200880603433000,"key":"transformer-remark-markdown-html-5d1b25e57217516f5d721208e23a6c76-gatsby-remark-imagesgatsby-remark-audiogatsby-remark-external-linksgatsby-remark-prismjs-","val":"<p>توی این فصل قراره نکات عمیق تری رو راجع به مدیریت استثنا ها یاد\nبگیریم بنابراین مفاهیم اولیه مثل اینکه exception چی هست و چرا باید\nاستفاده بشه و چطور میشه یک استثنا برای خودمون بنویسیم رو ذکر نمی‌کنم.</p>\n<h2>یادآوری</h2>\n<p>نکته اول اینکه همیشه باید سعی کنیم توی بلوک catch، تایپ مربوط به\nexception رو به صورت رفرنس بگیریم چراکه اولا از کپی شدن آبجکت اکسپشن\nجلوگیری میکنه و دوم اینکه باعث میشه اگر اکسپشن ما از stdexcept ارث بری\nشده، بتونه به درستی اجرا بشه.</p>\n<p>یه بلاک try میتونه چندین بلاک catch رو بعد از خودش داشته باشه که هرکدوم یک استثنا خاصی رو هندل میکنن.</p>\n<p><strong>دو نوع مدل برای هندل کردن استثنا داریم:</strong> </p>\n<h2>termination model of exception handling</h2>\n<p>توی این مدل(که زبان سی++ از این مدل استفاده می‌کنه) وقتی داخل try یک\nاکسپشن پرت میشه(throw)، در همون نقطه از بلاک try بیرون میاد(اصطلاحا بهش\nمیگن throw point) و بعد از پیدا کردن بلاک catch مورد نظرش میره و خطی که\nبعد از catch هست رو اجرا میکنه. نه خطی که بعد از throw point هست.</p>\n<h2>resumption model of exception handling</h2>\n<p>این مدل برعکس مدل بالاست و وقتی کار بلوک catch تموم میشه، برمیگرده و\nاز ادامهٔ throw point یا همون نقطه پرتاب کد هارو اجرا می‌کنه.</p>\n<p>با اینکه کلمهٔ throw میتونه هر چیزی رو پرت بکنه(مثل return) اما بهتره که فقط exception object رو پرت کنیم.</p>\n<h2>پرت کردن دوباره یک استثنا یا rethrowing exception</h2>\n<p>گاهی ممکنه وضعیتی پیش بیاد که نیاز باشه یک استثنا رخ داده شده رو\nچندبار پردازش کنیم. به عنوان مثال فرض کنید در یک تابع چند حافظه رو <code class=\"language-text\">new</code> کردیم و بعد از تخصیص حافظه و در جایی از این تابع یک exception پرت بشه. اینجا ما میخوایم هم حافظه ای که گرفته شده رو <code class=\"language-text\">delete</code> کنیم و هم به تابع صدا زننده‌مون اطلاع بدیم که در این تابع یک استثنا رخ داده. </p>\n<p>برای اینکه اینکار انجام بشه کافیه در بلوک catch ای که داریم یکبار دیگه <code class=\"language-text\">throw</code> کنیم تا به تابع صدا زننده بره. کد زیر کاملا شفافه و با خوندنش میتونیم بفهمیم دقیقا منظور از rethrowing exception چیه.</p>\n<p><img src=\"https://seedpuller.space/wp-content/uploads/2020/07/image-4.png\"></p>\n<h2>Stack unwinding</h2>\n<p>وقتی یک استثنا پرتاب میشه، برنامه به دنبال یک بلوک catch می‌گرده که\nمتناسب با استثنا پرتاب شده باشه. اگر در جایی(تابعی) که قرار داره نتونه\nیک catch رو پیدا بکنه، اون تابع رو terminate می‌کنه و میره به جایی که\nتابع ما داخلش صدا زده شده. اگر اونجا هم بلوک catch ای وجود نداشت که\nمتناسب با استثنا پرت شده بود، باز هم تابع رو terminate میکنه و میره به\nتابع صدا زننده‌ش و این کار تا موقعی که بتونه یک catch رو پیدا کنه ادامه\nداره.</p>\n<p>اگر هیچ catch متناسبی پیدا نشه در نهایت برنامه بسته میشه.</p>\n<p>به این فرآیند میگن stack unwinding چراکه function stack رو پیمایش می‌کنه و دونه دونه به سمت تابع بیرونی حرکت می‌کنه.</p>\n<p>مثال زیر به روشن شدن ماجرا کمک می‌کنه:</p>\n<p><img src=\"https://seedpuller.space/wp-content/uploads/2020/07/image-5.png\"></p>\n<p><img src=\"https://seedpuller.space/wp-content/uploads/2020/07/image-6.png\"></p>\n<h2>کلمه <code class=\"language-text\">noexcept</code></h2>\n<p>اگر تابعی داشته باشیم که به هیچ عنوان استثنا ای رو پرت نمی‌کنه یا\nتوابعی رو صدا میزنه که اونها هم استثنا ای رو پرت نمی‌کنن، میتونیم صراحتا\nبه عنوان تابعی که استثنا نداره تعریفش کنیم:</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">int</span> <span class=\"token function\">functionWithoutException</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">noexcept</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>اینکار به کسای دیگه (و حتی خودمون) کمک میکنه که وقتی داریم کد رو\nمی‌خونیم بدونیم این تابع هیچجوره استثنا رو پرت نمی‌کنه و بنابراین با\nخیال راحت میتونیم خارج از بلوک try قرارش بدیم.</p>\n<p>نکته: اگر تابع ما const هست،‌ حتما کلمهٔ <code class=\"language-text\">noexcept</code> رو باید بعد از <code class=\"language-text\">const</code> بذاریم. نمیدونم چرا.</p>\n<h2>استثنا در Constructor و Destructor</h2>\n<p>یه سری نکات وجود داره که بهش می‌پردازیم:</p>\n<ul>\n<li>از اشیاء ای که به صورت گلوبال تعریف شدن و اشیاء ای که به صورت <code class=\"language-text\">static</code> تعریف شدن نباید استثنا ای پرت بشه چرا که این اشیاء قبل از <em>main</em> ساخته میشن و نمیشه <code class=\"language-text\">catch</code> کردشون.</li>\n<li>اگر یک شئ رو با استفاده از <code class=\"language-text\">new</code> ساخته باشیم و در کانستراکتورش یک استثنا رخ بده، اون حافظه ای که گرفته شده خود به خود آزاد میشه.</li>\n<li>اگر کانستراکتور حافظه ای رو تخصیص داده، قبل از اینکه استثنا ای رو پرت بکنه باید حتما حافظه ای که گرفته رو پاک کنه! </li>\n</ul>\n<h2>استثنا ها در new</h2>\n<p>یکی از ویژگی های جالب سی++ که نظرمو جلب کرد، تابع <code class=\"language-text\">set_new_handler</code> (از هدر <code class=\"language-text\">&lt;new></code>)بود.\nاین تابع یک تابع(بدون ورودی و خروجی void) رو به عنوان ورودی خودش میگیره\nو هر زمان و هرجای برنامه که موقع new کردن یک حافظه، مشکلی ایجاد بشه،\nاون تابع رو فراخوانی می‌کنه.</p>\n<p>اگر تابع handler رجیستر نشده باشه،‌ در حالت پیشفرض <code class=\"language-text\">new</code> میاد و استثنا <code class=\"language-text\">bad_alloc</code> رو پرتاب می‌کنه.</p>\n<h2>کلاس <code class=\"language-text\">unique_ptr</code></h2>\n<p>توضیحاتش زیاده ولی اگر مختصر بخوام بگم، یکی از اشاره گر های هوشمند\nسی++ هست که این نیاز رو که مجبوریم هر حافظه ای که گرفتیم رو به صورت دستی\n<code class=\"language-text\">delete</code> کنیم از بین می‌بره. خودش به صورت خودکار وقتی که out of scope بشه، حافظه رو برمیگردونه به سیستم.</p>\n<p>یه مثال ازش میزنم: (کلاس Integer کار خاصی نمی‌کنه. فقط موقع نابود شدن یه متن چاپ میکنه و یه setter و getter داره)<img src=\"https://seedpuller.space/wp-content/uploads/2020/08/image.png\"></p>\n<p>تابع <code class=\"language-text\">make_unique</code> درواقع کار همون <code class=\"language-text\">new</code> رو انجام می‌ده و خط ۱۴ رو میشه به این شکل هم نوشت:</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\">unique_ptr<span class=\"token operator\">&lt;</span>Integer<span class=\"token operator\">></span> ptrToInteger <span class=\"token punctuation\">{</span><span class=\"token keyword\">new</span> <span class=\"token function\">Integer</span><span class=\"token punctuation\">(</span><span class=\"token number\">7</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span></code></pre></div>\n<h3>مالکیت در <code class=\"language-text\">unique_ptr</code></h3>\n<p>هر اشاره گری فقط میتونه توسط یک شئ <code class=\"language-text\">unique_ptr</code> مدیریت بشه\nو این امکان که یک اشاره گر توسط چند شئ مدیریت بشن وجود نداره. درواقع\nوقتی یک شئ از این کلاس به یک شئ دیگه نسبت داده میشه(assign)، مالکیت\nاشاره گر از شئ سمت راست به شئ سمت چپ منتقل میشه. </p>\n<p>این موضوع باعث میشه که بتونیم از <code class=\"language-text\">unique_ptr</code> برای پاس دادن آرگومان ها به تابع و یا برگردوندن اشاره گر از یک تابع استفاده بکنیم.</p>\n<h2>سلسله مراتب Exception های استاندارد</h2>\n<p><img src=\"https://seedpuller.space/wp-content/uploads/2020/08/image-1.png\"></p>\n<p>با catch کردن کلاس والد، همه استثنا هایی که فرزند اون کلاس هستند هم catch می‌شن.</p>\n<p>اگر می‌خوایم همهٔ انواع استثنا هارو catch بکنیم، میتونیم اینطوری بنویسیم:</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n <span class=\"token comment\">// code here </span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>یکی از بدیای این روش اینه که دیگه نمی‌تونیم به جزئیات ارور دسترسی\nداشته باشیم. البته، اگر در سطوح پایین تر(توابعی که تابع موجود رو صدا\nزدند) catch ای وجود داشته باشه، میتونیم با rethrow کردن استثنا به جزئیات\nهم دسترسی داشته باشیم.</p>\n<h2>پایان</h2>\n<p>در فصل بعد درباره Template ها صحبت می‌کنیم. فصل باحالیه.</p>"}