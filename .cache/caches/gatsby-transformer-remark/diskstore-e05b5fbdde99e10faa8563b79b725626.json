{"expireTime":9007200880603433000,"key":"transformer-remark-markdown-html-f1a9212c74be426008ddb382130932ca-gatsby-remark-imagesgatsby-remark-audiogatsby-remark-external-linksgatsby-remark-prismjs-","val":"<p>تقریبا یه هفته طول کشید تا پاراگراف آخر این پست رو بنویسم که درباره‌ی\nچند ریختی یا polymorphism توی سی++ عه. دلیلش هم همون بهونه‌ی قدیمیم،\nحال نداشتن، بود. احتمالا وقتی این متن رو میخونید متوجه میشید که به شدت\nبا بی‌حوصلگی نوشته شده، مثال زیاد نزدم و کدی هم ننوشتم. دلیلش هم که خب\nواضحه.</p>\n<p>چند ریختی به ما اجازه میده که برنامه های گسترده ای بنویسیم و درواقع\nبتونیم برنامه نویسی general داشته باشیم بجای اینکه مجبور بشیم به صورت\nخاص برنامه بنویسیم(الآن براش مثالی توی ذهنم ندارم که کوتاه باشه).</p>\n<h2>کلمه‌ی <code class=\"language-text\">virtual</code></h2>\n<p>معمولا وقتی از طریق یه پوینتر توابع رو فراخوانی می‌کنیم، توابع مربوط\nبه [جنس اون] پوینتر صدا زده میشن نه توابع مربوط به کلاسی که بهش اشاره\nمیشه. یعنی اگه تابعی با دو نسخه(یکی توی کلاس والد و یکی توی کلاس فرزند)\nوجود داشته باشه، اون نسخه ای صدا زده میشه که مربوط به type پوینتره.\nvirtual به وجود اومده تا راه حلی برای این مشکل باشه، برای اینکه موقع صدا\nزدن یه تابع از طریق پوینتر/رفرنس، برنامه چک میکنه که اگر کلاس فرزند\nنسخه‌ی خودش از اون تابع رو داره، همون رو صدا بزنه در غیر این صورت نسخه‌ی\nمربوط به کلاس والد رو صدا می‌زنه.</p>\n<p>درواقع توابع ویرچوال ابن امکان رو فراهم میکنن که بجای فراخوانی تابع مربوط به هندل، تابع مربوط به کلاس اشاره شده فراخوانی بشه.</p>\n<p>بهتره که برای خوانایی بهتر توی هر سطح که توابع virtual والد رو بازنویسی می‌کنیم، قید کنیم که این یه تابع virtual عه.</p>\n<h2>Dynamic Binding</h2>\n<p>همونطور که بالاتر گفتیم اگر یکی از توابع به شکل virtual تعریف شده\nباشه، و این تابع از طریق یه پوینتر/رفرنس فراخوانی بشه، برنامه خودش تابع\nمناسب رو بر اساس جنسِ شئ ای که داره بهش اشاره میشه انتخاب میکنه. به این\nفرآیند میگن dynamic binding.</p>\n<h2>کلمه‌ی <code class=\"language-text\">override</code></h2>\n<p>وقتی یه تابعی از کلاس والد رو توی کلاس فرزند بازنویسی می‌کنیم، بهتره\nکه از کلمه‌ی override براش استفاده بکنیم، با استفاده کردن این کلمه،\nکامپایلر چک میکنه که آیا تابعی با امضا(signature) مشابه توی کلاس(های)\nوالد وجود داره که بخواد بازنویسی بشه یا نه.</p>\n<h2>ضرورت <code class=\"language-text\">virtual</code> کردن destructor</h2>\n<p>مهمه که اگر میخوایم به صورت چند ریختی از کدمون استفاده بکنیم، حتما destructor رو به صورت virtual تعریف کنیم.</p>\n<p>دلیلش اینه که اگر یک اشاره گر از نوع کلاس والد که داره به یک شئ از\nکلاس فرزند اشاره میکنه توسط کلمه‌ی delete پاک بشه، تابع نابودکننده مربوط\nبه خودش صدا زده بشه و نه تابع نابودکننده والد.</p>\n<h2>کلمه‌ی <code class=\"language-text\">default</code></h2>\n<p>چیز جدیدی که به سی++ ۱۱ اضافه شده کلمه‌ی default هست. وقتی میخوایم یه\nکانستراکتور و یا دیستراکتور پیش فرض داشته باشیم دیگه نیاز نیست که یه\nتابع با بدنه‌ی خالی بنویسیم. فقط کافیه توی اعلان، اون تابع رو default\nکنیم.</p>\n<h2>کلمه‌ی <code class=\"language-text\">final</code></h2>\n<p>وقتی از کلمه‌ی final برای یه تابع استفاده میشه، دیگه کامپایلر اجازه\nنمیده که اون تابع توی کلاس های فرزند بازنویسی و override بشه. </p>\n<p>وقتی از کلمه‌ی final برای تعریف یه کلاس استفاده بشه، کامپایلر اجازه نمیده که کلاس های دیگه از این کلاس ارث بری داشته باشن.</p>\n<h2>کلاس Abstract</h2>\n<p>تا اینجا ما میتونستیم از کلاس هامون اشیاء ای رو بسازیم. اما یه سری\nکلاس های دیگه هم وجود دارن که نمیشه ازشون هیچ شئ ای ساخت که به این کلاس\nها میگن Abstract. به کلاس های معمولی میگن concrete.</p>\n<p>کلاسی رو میشه ابسترکت نامید که حداقل یکی از توابع virtual اش به صورت pure باشه.</p>\n<p>برای اینکه یک تابع رو pure کنیم، باید اعلان تابع رو برابر 0 قرار بدیم\nکه اون 0 نشان pure specifier هست. با pure اعلام کردن یک تابع دیگه نباید\nبراش پیاده سازی ای نوشت بنابراین همه‌ی کلاس های فرزند باید توابع pure\nرو پیاده سازی کنن وگرنه خودشونم ابسترکت میشن.</p>\n<h2>چندریختی به صورت عمیق تر!</h2>\n<p>یه رفتار پلی مورفیک از سه سطح از پوینتر ها تشکیل شده. </p>\n<h4>مرحله اول، vtable</h4>\n<p>وقتی کامپایلر کلاسی که دارای توابع virtual عه رو کامپایل میکنه، برای\nاون کلاس یدونه Virtual function Table (vtable) میسازه. کار این جدول چیه؟\nآدرس توابع virtual شده‌ی اون کلاس رو داخل خودش ذخیره می‌کنه. وقتی در\nزمان اجرا میخوایم با استفاده از dynamic binding یه تابع virtual رو\nفراخوانی کنیم، برنامه توی vtable کلاس مربوطه میگرده تا تابع درست رو پیدا\nو اجرا بکنه.</p>\n<h4>مرحله دوم</h4>\n<p>وقتی یه آبجکت از یک کلاس دارای توابع ویرچوال ساخته میشه، کامپایلر<br>\nبه اون آبجکت یه پوینتر اختصاص میده(این پوینتر رو معمولا در اول آبجکت\nمیذاره) که اون پوینتر به vtable مربوط به اون کلاس اشاره می‌کنه.</p>\n<h4>مرحله سوم</h4>\n<p>پوینتریه که به خودِ شئ اشاره می‌کنه. به عنوان مثال ما یک وکتور از\nهمه اشیاء از کلاس های مشتق شده از کلاس A داریم. پوینتر هایی که توی این\nوکتور هستند(که به اشیاء اشاره می‌کنن) به عنوان سطح سوم پوینتر ها محسوب\nمیشن.</p>\n<p>بنابراین برای اجرای یه تابع ویرچوال که به صورت dynamic binding میخواد\nصدا زده بشه، حداقل ۳ بار pointer dereferencing اتفاق میوفته که این موجب\nافزایش زمان اجرایی میشه. همچنین ذخیره کردن پوینتر مرحله ۲ و خودِ vtable\nهم باعث استفاده بیشتر از مموری میشه. اگر پرفورمنس و سرعت توی برنامه ای\nکه داریم می‌نویسیم یک اصل بسیار مهم و سفت و سخته،‌ بهتره که از پلی\nمورفیسم استفاده نکنیم.</p>\n<h2>RunTime Type Information</h2>\n<p>تا اینجا وقتی به صورت پلی‌مورفیسم کار می‌کردیم، نیاز نبود بدونیم هر\nآبجکت دقیقا از چه نوعیه. اما ممکنه گاهی این نیاز رو پیدا بکنیم. با\nاستفاده از قابلیت RTTI یا همون RunTime Type Information و قابلیت dynamic\ncast میتونیم در زمان اجرا بفهمیم که شئ ما از چه نوعیه و رفتار متناسب با\nخودش رو باهاش انجام بدیم. با استفاده از dymanic<em>cast میتونیم یه اشاره\nگر از جنس کلاس والد رو که داره به یکی از کلاس های فرزند اشاره می‌کنه به\nیک اشاره گر از نوع خودِ کلاس فرزند تغییر بدیم. فرقش با static</em>cast اینه\nکه تایپ چک انجام میده و اگر کلاسی که داره بهش اشاره میشه از نوع کلاسی\nنباشه که میخواد بهش cast بشه، تبدیل انجام نمیشه.</p>\n<p>همچنین با استفاده از typeid میتونیم در زمان اجرا بفهمیم که یه شئ از\nچه نوعیه. با استفاده از متود name اش میتونیم اسم جنسِ یه شئ رو به صورت\nیه رشته بگیریم.</p>\n<h2>در پایان</h2>\n<p>فصل بعدی توی I/O بیشتر عمیق میشیم.</p>"}