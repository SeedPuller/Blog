<!DOCTYPE html><html lang="fa-IR" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="pv-cache-enabled" content="false"><meta name="generator" content="Jekyll v4.2.0" /><meta property="og:title" content="فصل ۱۶ دایتل: الگوریتم های موجود در کتابخانه استاندارد" /><meta name="author" content="سیدپولر" /><meta property="og:locale" content="fa_IR" /><meta name="description" content="در این فصل قراره که یاد بگیریم چطور با استفاده از iterator ها و algorithm(الگوریتم) های موجود در کتابخانه استاندارد سی++ یا همون STL کارهامون رو پیش ببریم. یاد میگیریم که توابع لاندا چی هستن و چطور ازشون استفاده بکنیم، اشاره گر به تابع چیه و چطور میشه ازش استفاده کرد و چیز های دیگه." /><meta property="og:description" content="در این فصل قراره که یاد بگیریم چطور با استفاده از iterator ها و algorithm(الگوریتم) های موجود در کتابخانه استاندارد سی++ یا همون STL کارهامون رو پیش ببریم. یاد میگیریم که توابع لاندا چی هستن و چطور ازشون استفاده بکنیم، اشاره گر به تابع چیه و چطور میشه ازش استفاده کرد و چیز های دیگه." /><link rel="canonical" href="https://www.seedpuller.ir/posts/deitel-chapter16-stl-algorithms/" /><meta property="og:url" content="https://www.seedpuller.ir/posts/deitel-chapter16-stl-algorithms/" /><meta property="og:site_name" content="سیدپولر" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2020-07-22T00:00:00+04:30" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="فصل ۱۶ دایتل: الگوریتم های موجود در کتابخانه استاندارد" /><meta name="twitter:site" content="@twitter_username" /><meta name="twitter:creator" content="@سیدپولر" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"author":{"@type":"Person","name":"سیدپولر"},"description":"در این فصل قراره که یاد بگیریم چطور با استفاده از iterator ها و algorithm(الگوریتم) های موجود در کتابخانه استاندارد سی++ یا همون STL کارهامون رو پیش ببریم. یاد میگیریم که توابع لاندا چی هستن و چطور ازشون استفاده بکنیم، اشاره گر به تابع چیه و چطور میشه ازش استفاده کرد و چیز های دیگه.","url":"https://www.seedpuller.ir/posts/deitel-chapter16-stl-algorithms/","@type":"BlogPosting","headline":"فصل ۱۶ دایتل: الگوریتم های موجود در کتابخانه استاندارد","dateModified":"2020-07-22T00:00:00+04:30","datePublished":"2020-07-22T00:00:00+04:30","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.seedpuller.ir/posts/deitel-chapter16-stl-algorithms/"},"@context":"https://schema.org"}</script><title>فصل ۱۶ دایتل: الگوریتم های موجود در کتابخانه استاندارد | سیدپولر</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id="></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', ''); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="https://avatars.githubusercontent.com/u/24620298?s=460&u=dd6165c7d8103164b24d6f40a169594a2c8dac42&v=4" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">سیدپولر</a></div><div class="site-subtitle font-italic">نوشته های مور دانه‌کش</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/SeedPuller" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['SeedPuller','gmail.com'].join('@')" aria-label="email" class="order-4" > <i class="fas fa-envelope"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Posts </a> </span> <span>فصل ۱۶ دایتل: الگوریتم های موجود در کتابخانه استاندارد</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8" style="direction: rtl; text-align: right;"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip style="direction: rtl; text-align: right;">فصل ۱۶ دایتل: الگوریتم های موجود در کتابخانه استاندارد</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Wed, Jul 22, 2020, 12:00 AM +0430" > Jul 22, 2020 <i class="unloaded">2020-07-22T00:00:00+04:30</i> </span> توسط <span class="author"> سیدپولر </span></div><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="حاوی 1455 کلمه"> 8 دقیقه</span></div></div><div class="post-content"><p>در این فصل قراره که یاد بگیریم چطور با استفاده از iterator ها و algorithm(الگوریتم) های موجود در کتابخانه استاندارد سی++ یا همون STL کارهامون رو پیش ببریم. یاد میگیریم که توابع لاندا چی هستن و چطور ازشون استفاده بکنیم، اشاره گر به تابع چیه و چطور میشه ازش استفاده کرد و چیز های دیگه.</p><h2 id="نکاتی-درباره-پیمایشگر-ها-iterators">نکاتی درباره پیمایش‌گر ها (Iterators)</h2><p>اینکه یه کانتینر از چه iterator هایی پشتیبانی میکنه مشخص کنندهٔ اینه که از چه الگوریتم هایی میشه برای این کانتینر استفاده کرد. به عنوان مثال کانتینر های vector و array. این دو کانتینر از random-access iterator پشتیبانی میکنن(وقتی از این نوع پشتیبانی میکنن یعنی از بقیه انواع پیمایش کننده ها هم پشتیبانی میکنن) و این یعنی همهٔ الگوریتم های موجود رو میشه براشون استفاده کرد. البته نکته اینجاست که الگوریتم هایی که سایز کانتینر رو تغییر میدن برای array قابل استفاده نیستن. بنابراین مهم نیست که کانتینر چیه، اگه اون کانتینر، حداقل نوع iterator مورد نیاز برای یه الگوریتم رو ساپورت بکنه، میشه از اون الگوریتم براش استفاده کرد.</p><h3 id="باطل-شدن-پیمایش-ها-iterator-invalidation">باطل شدن پیمایش ها (iterator invalidation)</h3><p>ایتریتور ها درواقع یک اشاره گر کپسوله شدن هستند که به عناصر کانتینر اشاره میکنن بنابراین ممکنه در صورت بروز یک سری تغییرات در کانتینر (که به کانتینر بستگی داره)، این اشاره گر اعتبارشو از دست بده و باطل بشه. پروسه invalidate شدن اشاره گر ها، رفرنس ها و ایتریتور ها در بخش 23 استاندارد سی++ موجوده و ما اینجا فقط خلاصه ای از اونها رو بررسی می‌کنیم.</p><h4 id="اضافه-کردن-یه-عنصر-به-کانتینر">اضافه کردن یه عنصر به کانتینر:</h4><ul><li>در <span dir="ltr"><code class="language-plaintext highlighter-rouge">&lrm;vector</code></span>&rlm; ها، اگر اضافه کردن عنصر ما باعث بشه که وکتور اقدام به درخواست فضای بیشتر و در نتیجه reallocate شدن بکنه، تمام iterator هایی که مربوط به این وکتور بودن باطل میشن. در غیر این صورت، هر iterator ای که به فضای بین مکان عنصری که تازه اضافه شده و مکان آخرین عنصر موجود اشاره میکنه باطل میشه.<li>در <span dir="ltr"><code class="language-plaintext highlighter-rouge">&lrm;deque</code></span>&rlm; ها، همه iterator ها باطل میشن.<li>در <span dir="ltr"><code class="language-plaintext highlighter-rouge">&lrm;list</code></span>&rlm; , <span dir="ltr"><code class="language-plaintext highlighter-rouge">&lrm;forward_list</code></span>&rlm; و ordered associative container ها هیچ تغییری در iterator ها بوجود نمیاد<li>در unordered associative container ها تنها اگر عمل reallocation انجام بگیره، همه iterator ها باطل میشن.</ul><h4 id="حذف-کردن-یک-عنصر-از-کانتینر-باعث-میشه-iterator-ای-که-به-اون-عنصر-اشاره-میکنه-باطل-بشه-علاوه-بر-اون">حذف کردن یک عنصر از کانتینر باعث میشه iterator ای که به اون عنصر اشاره می‌کنه باطل بشه. علاوه بر اون:</h4><ul><li>در وکتور ها از اونجایی که عنصر حذف شده تا آخرین عنصر هر پیمایش‌گری وجود داشته باشه غیر فعال میشه<li>در <span dir="ltr"><code class="language-plaintext highlighter-rouge">&lrm;deque</code></span>&rlm; ها اگر حذفی که رخ داده در جایی غیر از ابتدا یا انتهای کانتینر باشه باعث میشه کل پیمایشگر ها باطل بشن.</ul><h2 id="توابع-لاندا">توابع لاندا</h2><p>خیلی از الگوریتم های موجود در STL میتونن <strong>یک تابع‌‌‌‌‌‌</strong> رو به عنوان ورودی خودشون داشته باشن. همونطور که قبلا می‌دونیم، اسم یک تابع به صورت ضمنی یک اشاره گر به ابتدای کد اون تابع هست. اما یک راه هم وجود داره که تابع خودمون رو منحصرا برای اون الگوریتمی که داریم ازش استفاده میکنیم بنویسیم و اون رو دقیقا کنار بقیه آرگومان ها بنویسیم! برای اینکار یک مفهوم به اسم <strong>توابع لاندا</strong> به کارمون میاد که در واقع توابعی هستند که اسم ندارند و اصطلاحا بهشون میگن anonymous function.</p><p>برای اینکه دقیق تر متوجه بشیم، یه مثال رو بررسی می‌کنیم:</p><p>یکی از الگوریتم های جالبی که در STL وجود داره، اسمش <span dir="ltr"><code class="language-plaintext highlighter-rouge">&lrm;for_each</code></span>&rlm; هست. این تابع میاد بازه ای از یک کانتینر رو میگیره و تابعی که ما بهش میدیم رو برای تمام عناصر موجود در اون بازه اجرا میکنه. بهتره که کد رو ببینیم:<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://seedpuller.space/wp-content/uploads/2020/07/image-3.png" alt="" /></p><p>خب همونطور که می‌بینیم، تابع <span dir="ltr"><code class="language-plaintext highlighter-rouge">&lrm;for_each</code></span>&rlm; برای دوتا آرگومان اولش دوتا iterator میگیره و آرگومان سومش یه تابع رو به عنوان ورودی دریافت می‌کنه. توی این مثال ما دوتا for_each زدیم که اولی میاد و صرفا عناصر رو ضربدر ۲ میکنه و چاپ می‌کنه و دومی میاد جمع همهٔ عنصر هارو محاسبه می‌کنه. چجوریش رو میگم حالا.</p><h3 id="سینتکس-توابع-لاندا">سینتکس توابع لاندا</h3><p>خب آرگومان اول و دوم که واضحن. میمونه آرگومان سوم که یه تابع لانداست. سینتکس توابع لاندا این شکلی ان:</p><div class="language-cpp highlighter-rouge"><div class="highlight" style="direction: ltr; text-align: left;"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="p">[</span><span class="n">introducer</span><span class="p">](</span><span class="n">input</span> <span class="n">arguments</span><span class="p">)</span> <span class="p">{</span><span class="n">function</span>  <span class="n">body</span><span class="p">}</span>
</pre></table></code></span>&rlm;</div></div><p>خب همونطور که می‌بینید توابع لاندا با یک [] شروع میشن که اصطلاحا بهشون میگن <strong><em>lambda introducer</em></strong>. بقیه‌ش تقریبا مثل تابع معمولیه و لیست پارامتر های ورودی میاد و در ادامه بدنه تابع قرار داره.</p><p>توابع لاندا میتونن به متغییر های محلی(local) جایی که دارن داخلش تعریف میشن دسترسی داشته باشن. مثلا توی مثال بالا تابع های لاندای ما میتونن به متغییر هایی که داخل main تعریف شده دسترسی داشته باشن. اینجاست که lambda introducer به کار میاد. درواقع lambda introducer به ما اجازه میده که مشخص کنیم از کدوم متغییر های موجود میخوایم استفاده کنیم. به اینکار اصطلاحا میگن <strong><em>capture</em></strong> کردن متغییر ها.</p><p>توی اولین <span dir="ltr"><code class="language-plaintext highlighter-rouge">&lrm;for_each</code></span>&rlm; می‌بینیم که lambda introducer خالیه و این یعنی تابع لاندای ما نمیخواد از هیچ متغییری استفاده کنه. و توی دومی ما این رو می‌بینیم: <span dir="ltr"><code class="language-plaintext highlighter-rouge">&lrm;[&amp;sum]</code></span>&rlm; و این یعنی رفرنسی از متغییر <span dir="ltr"><code class="language-plaintext highlighter-rouge">&lrm;sum</code></span>&rlm; رو در دسترس تابع قرار میده که ازش استفاده بکنه. دلیل اینکه از رفرنس استفاده شده هم اینه که بتونیم متغییر اصلی که داخل <span dir="ltr"><code class="language-plaintext highlighter-rouge">&lrm;main</code></span>&rlm; قرار داره رو modify کنیم.</p><h3 id="برگردوندن-مقدار-در-توابع-لاندا">برگردوندن مقدار در توابع لاندا</h3><p>تا الآن تابع های لاندای ما هیچ مقدار بازگشتی ای نداشتن و بنابراین به صورت پیشفرض مقدار بازگشتیشون به عنوان void مشخص میشد. اما اگر داخل تابع لاندامون یه return داشته باشیم نیاز داریم که نوع مقدار بازگشتی رو از طریق سینتکس trailing return type مشخص کنیم.</p><p>اینطوریه :</p><div class="language-cpp highlighter-rouge"><div class="highlight" style="direction: ltr; text-align: left;"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="o">-&gt;</span> <span class="n">type</span>
</pre></table></code></span>&rlm;</div></div><p>که اگر بخوام توی کد نشون بدم اینطوری میشه:</p><div class="language-cpp highlighter-rouge"><div class="highlight" style="direction: ltr; text-align: left;"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="p">[]</span> <span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="p">{</span><span class="k">return</span> <span class="mi">2</span><span class="p">}</span>
</pre></table></code></span>&rlm;</div></div><p>همونطور که می‌بینیم، جاش بین لیست پارامتر ها و بدنه تابع‌ست.</p><h2 id="الگوریتم-ها">الگوریتم ها</h2><p>این بخش از فصل تعداد زیادی الگوریتم رو توضیح داده ولی من فقط اونایی که به نظرم بدرد بخور تر یا جالب تر میان رو اینجا می‌نویسم.</p><h3 id="mismatch"><span dir="ltr"><code class="language-plaintext highlighter-rouge">&lrm;mismatch</code></span>&rlm;</h3><p>وظیفهٔ این تابع اینه که بین دوتا کانتینر بگرده و اونجایی که دوتا خونه متناظر باهم یک مقدار مساوی نداشته باشن، می‌ایسته و اطلاعات اون مکان رو (به شکل یک <span dir="ltr"><code class="language-plaintext highlighter-rouge">&lrm;pair</code></span>&rlm; از iterator های هردو کانتینر) بهمون برمیگردونه. این تابع ۴ تا ورودی داره(اونی که توی کتاب نشون داده اینطوریه) که دوتای اول بازه رو برای کانتینر اول مشخص میکنن و دوتای دوم بازه رو برای کانتینر دوم مشخص میکنن.</p><h3 id="inserter-ها">inserter ها</h3><p>بیاین تابع merge رو باهم ببینیم:</p><div class="language-cpp highlighter-rouge"><div class="highlight" style="direction: ltr; text-align: left;"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">a1</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">};</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">a2</span><span class="p">{</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">};</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">result</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">merge</span><span class="p">(</span><span class="n">a1</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">a1</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">a2</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">a2</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">result</span><span class="p">.</span><span class="n">begin</span><span class="p">());</span>
</pre></table></code></span>&rlm;</div></div><p>توی مثال بالا، وکتور result باید حتما به اندازه ۶ تا خونه جا داشته باشه تا a1 و a2 داخلش ذخیره بشن. بنابراین باید قبل از اجرای تابع <span dir="ltr"><code class="language-plaintext highlighter-rouge">&lrm;merge</code></span>&rlm; ، باید تخصیص حافظه صورت بگیره.</p><p>اما زمانی هست که ما نمی‌خوایم از قبل حافظه ای تخصیص بدیم و میخوایم یک کلاسی مثل وکتور، خودش اینکار رو به ازای اضافه شدن عناصر جدید انجام بده. اینجاست که inserter ها (از هدر iterator) به کمک ما میان. مثال بالا اگر اجرا بشه به مشکل میخوره چراکه result به اندازه کافی جا نداره. حالا با استفاده از inserter این مشکل رو برطرف می‌کنیم:</p><div class="language-cpp highlighter-rouge"><div class="highlight" style="direction: ltr; text-align: left;"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">a1</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">};</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">a2</span><span class="p">{</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">};</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">result</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">merge</span><span class="p">(</span><span class="n">a1</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">a1</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">a2</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">a2</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">back_inserter</span><span class="p">(</span><span class="n">result</span><span class="p">));</span>
</pre></table></code></span>&rlm;</div></div><p>تابع back_inserter درواقع میاد و به ازای هر عنصری که میخواد به result اضافه بشه، تابع <span dir="ltr"><code class="language-plaintext highlighter-rouge">&lrm;push_back</code></span>&rlm; مربوط به کانتینر result رو صدا می‌زنه. به همین راحتی (:</p><h2 id="function-object-ها">Function Object ها</h2><p>همونطور که می‌دونیم، بسیاری از الگوریتم های موجود در کتابخونه استاندارد میتونن یک تابع رو به عنوان آرگومان آخرشون بگیرن. تا اینجا دیدیم که این تابع میتونه یک function pointer یا یک تابع لاندا (lambda function) باشه. کلاس هایی که میتونن توابع لاندا یا اشاره گر به توابع رو به عنوان ورودی بگیرن، میتونن یک نوع دیگه از تابع رو هم دریافت کنن که اسمش function object هست. function object درواقع یک شئ از کلاسی هست که اوپراتور پرانتزش overload شده. یعنی ما در member function های کلاس، یک تابع به اسم <span dir="ltr"><code class="language-plaintext highlighter-rouge">&lrm;operator()</code></span>&rlm; تعریف کردیم.</p><p>اشیاء ای که از این کلاس ما ساخته میشن میتونن بجای تابع لاندا یا اشاره گر به تابع استفاده بشن.(درواقع خود توابع لاندا توسط کامپایلر به یک اشاره گر به تابع یا function object تبدیل میشن تا بشه روشون بهینه سازی انجام داد).</p><p>در بیشتر جاها(و نه همه جا) میشه بجای function object از تابع لاندا یا اشاره گر به تابع استفاده کرد.</p><p>از طریق هدر <span dir="ltr"><code class="language-plaintext highlighter-rouge">&lrm;&lt;functional&gt;</code></span>&rlm; میتونیم به function object های از پیش تعریف شده <em>STL</em> دسترسی داشته باشیم که خیلی هم کاربردی و خفنن. تابع less<T> که توی مثال های بالا(بخش set و …) دیدیم جزئی از function object های موجود در _STL_ عه.</T></p><h3 id="مزایای-function-object-ها">مزایای function object ها</h3><p>اولین تفاوتش با لاندا و امثالهم اینه که از اونجایی که عضوی از یک کلاسه، کامپایلر راحت تر میتونه بهینه سازی هایی مثل inline کردن رو انجام بده.</p><p>دومین تفاوت که یک نقطه قوت محسوب میشه، قابلیت استفاده از data member های کلاس هست.</p><h2 id="پایان">پایان</h2><p>این فصل هم تموم شد. مثل فصل های قبلی با تاخیر اما برخلاف فصل های قبلی، تاخیرش زیاد نبود! فصل بعدی توی مدیریت استثنا ها و خطا ها عمیق میشیم.</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/%D8%B3%DB%8C/'>سی++</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/algorithm/" class="post-tag no-text-decoration" >algorithm</a> <a href="/tags/c/" class="post-tag no-text-decoration" >C++</a> <a href="/tags/function-object/" class="post-tag no-text-decoration" >function object</a> <a href="/tags/iterator/" class="post-tag no-text-decoration" >iterator</a> <a href="/tags/lambda/" class="post-tag no-text-decoration" >lambda</a> <a href="/tags/lambda-functions/" class="post-tag no-text-decoration" >lambda functions</a> <a href="/tags/%D9%84%D8%A7%D9%86%D8%AF%D8%A7/" class="post-tag no-text-decoration" >لاندا</a> <a href="/tags/%D9%BE%DB%8C%D9%85%D8%A7%DB%8C%D8%B4%DA%AF%D8%B1/" class="post-tag no-text-decoration" >پیمایشگر</a> <a href="/tags/%D8%A7%D9%84%DA%AF%D9%88%D8%B1%DB%8C%D8%AA%D9%85/" class="post-tag no-text-decoration" >الگوریتم</a> <a href="/tags/%D8%AF%D8%A7%DB%8C%D8%AA%D9%84/" class="post-tag no-text-decoration" >دایتل</a> <a href="/tags/%D8%B3%DB%8C/" class="post-tag no-text-decoration" >سی++</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> این پست تحت مجوز <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> منتشر شده است.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">اشتراک گذاری</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=فصل ۱۶ دایتل: الگوریتم های موجود در کتابخانه استاندارد - سیدپولر&url=https://www.seedpuller.ir/posts/deitel-chapter16-stl-algorithms/" data-toggle="tooltip" data-placement="top" title="توئیتر" target="_blank" rel="noopener" aria-label="توئیتر"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://telegram.me/share?text=فصل ۱۶ دایتل: الگوریتم های موجود در کتابخانه استاندارد - سیدپولر&url=https://www.seedpuller.ir/posts/deitel-chapter16-stl-algorithms/" data-toggle="tooltip" data-placement="top" title="تلگرام" target="_blank" rel="noopener" aria-label="تلگرام"> <i class="fa-fw fab fa-telegram"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="کپی لینک پست"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/concurrency-in-cpp-chapter1/">همزمانی در سی++: مفاهیم اولیه</a><li><a href="/posts/concurrency-in-cpp-chapter3-5/">همزمانی در سی++(۵): جایگزین های mutex</a><li><a href="/posts/concurrency-in-cpp-chapter3-3/">همزمانی در سی++(۳): Dead Lock ها</a><li><a href="/posts/concurrency-in-cpp-chapter3-4/">همزمانی در سی++(۴): ژانگولر بازی با mutex و کارهای دیگر</a><li><a href="/posts/concurrency-in-cpp-chapter3-1/">همزمانی در سی++: اشتراک گذاری داده ها(۱)</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/c/">C++</a> <a class="post-tag" href="/tags/%D8%B3%DB%8C/">سی++</a> <a class="post-tag" href="/tags/inner-struggle/">Inner Struggle</a> <a class="post-tag" href="/tags/%D8%AF%D8%A7%DB%8C%D8%AA%D9%84/">دایتل</a> <a class="post-tag" href="/tags/%DB%8C%D8%A7%D8%AF%DA%AF%DB%8C%D8%B1%DB%8C/">یادگیری</a> <a class="post-tag" href="/tags/concurrency-in-action/">concurrency in action</a> <a class="post-tag" href="/tags/concurrent-processing/">concurrent processing</a> <a class="post-tag" href="/tags/%D8%A8%D8%B1%D9%86%D8%A7%D9%85%D9%87-%D9%86%D9%88%DB%8C%D8%B3%DB%8C-%DA%86%D9%86%D8%AF-%D9%86%D8%AE%DB%8C/">برنامه نویسی چند نخی</a> <a class="post-tag" href="/tags/%D8%B3%DB%8C-%DB%B1%DB%B7/">سی++۱۷</a> <a class="post-tag" href="/tags/%D9%85%D9%88%D8%A7%D8%B2%DB%8C-%DA%A9%D8%A7%D8%B1%DB%8C/">موازی کاری</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/what-ive-learned-from-deitel-chapter-15/"><div class="card-body"> <span class="timeago small" > Jul 21, 2020 <i class="unloaded">2020-07-21T00:00:00+04:30</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>نکات جدیدی که از فصل ۱۵ دایتل یاد گرفتم – کتابخانه استاندارد</h3><div class="text-muted small"><p> توی این فصل سه بخش از کتابخانه استاندارد سی++ که بهش STL هم میگن رو بررسی می‌کنیم. container ها، iterator ها و algorithm ها. فصل بسیار مهمیه چراکه این کتابخونه بسیاری از کار های مارو راحت تر می‌کن...</p></div></div></a></div><div class="card"> <a href="/posts/what-i-learned-from-deitel-chapter9/"><div class="card-body"> <span class="timeago small" > Mar 29, 2020 <i class="unloaded">2020-03-29T00:00:00+04:30</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>از فصل نهم کتاب برنامه نویسی سی++ دایتل چی یادگرفتم</h3><div class="text-muted small"><p> فصل نهم از کتاب C++ How To Program (نگارش ۲۰۱۷) رو تموم کردم و توی این پست نکاتی که از این فصل یادگرفتم(و یادم مونده=) ) رو می‌نویسم. تابع نابودگر (Destructor) علاوه بر ترتیب اجرا شدنش برای اشیاء...</p></div></div></a></div><div class="card"> <a href="/posts/what-ive-learned-from-deitel-chapter11/"><div class="card-body"> <span class="timeago small" > Apr 20, 2020 <i class="unloaded">2020-04-20T00:00:00+04:30</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>نکات جدیدی که از فصل ۱۱ سی++ دایتل یاد گرفتم – ارث بری</h3><div class="text-muted small"><p> این فصل از دایتل درباره‌ی ویژگی ارث‌بری توی سی++ بود. نکاتی که برام جدیده رو توی این پست نوشتم. تفاوت is-a relationship و has-a relationship وقتی یک کلاسی(A) از یک کلاس دیگه(B) ارث بری می‌کنه، می...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/what-ive-learned-from-deitel-chapter-15/" class="btn btn-outline-primary" prompt="قبلی"><p>نکات جدیدی که از فصل ۱۵ دایتل یاد گرفتم – کتابخانه استاندارد</p></a> <a href="/posts/deitel-chapter17-exception-handling/" class="btn btn-outline-primary" prompt="بعدی"><p>فصل ۱۷ دایتل: نگاهی عمیق تر به Exception Handling</p></a></div></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('.post-content img'); const observer = lozad(imgs); observer.observe(); </script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div><div class="footer-right" style="direction: rtl; text-align: right;"><p class="mb-0"> <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">مطالب این وبسایت تحت مجوز CC-BY-4.0 منتشر می‌شوند</span></p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/c/">C++</a> <a class="post-tag" href="/tags/%D8%B3%DB%8C/">سی++</a> <a class="post-tag" href="/tags/inner-struggle/">Inner Struggle</a> <a class="post-tag" href="/tags/%D8%AF%D8%A7%DB%8C%D8%AA%D9%84/">دایتل</a> <a class="post-tag" href="/tags/%DB%8C%D8%A7%D8%AF%DA%AF%DB%8C%D8%B1%DB%8C/">یادگیری</a> <a class="post-tag" href="/tags/concurrency-in-action/">concurrency in action</a> <a class="post-tag" href="/tags/concurrent-processing/">concurrent processing</a> <a class="post-tag" href="/tags/%D8%A8%D8%B1%D9%86%D8%A7%D9%85%D9%87-%D9%86%D9%88%DB%8C%D8%B3%DB%8C-%DA%86%D9%86%D8%AF-%D9%86%D8%AE%DB%8C/">برنامه نویسی چند نخی</a> <a class="post-tag" href="/tags/%D8%B3%DB%8C-%DB%B1%DB%B7/">سی++۱۷</a> <a class="post-tag" href="/tags/%D9%85%D9%88%D8%A7%D8%B2%DB%8C-%DA%A9%D8%A7%D8%B1%DB%8C/">موازی کاری</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://www.seedpuller.ir{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
