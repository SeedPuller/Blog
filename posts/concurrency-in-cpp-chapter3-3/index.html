<!DOCTYPE html><html lang="fa-IR" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="pv-cache-enabled" content="false"><meta name="generator" content="Jekyll v4.2.0" /><meta property="og:title" content="همزمانی در سی++(۳): Dead Lock ها" /><meta name="author" content="سیدپولر" /><meta property="og:locale" content="fa_IR" /><meta name="description" content="خب در پست قبل این مسئله که ترد ها برای استفاده از داده باهم مسابقه می‌دن رو کمی بررسی کردیم و یک راه حل دم دست هم براش پیشنهاد دادیم. توی این پست میخوایم در مورد مشکلی بحث کنیم که یجورایی برعکس Race condition هست. توی این مشکل، ترد ها منتظر همدیگه میمونن که از یه داده ای استفاده کنن. انقدر منتظر میمونن که عملا هیچکدومشون کاری دیگه انجام نمیده. به این مشکل چی میگن؟ می‌گن Dead Lock." /><meta property="og:description" content="خب در پست قبل این مسئله که ترد ها برای استفاده از داده باهم مسابقه می‌دن رو کمی بررسی کردیم و یک راه حل دم دست هم براش پیشنهاد دادیم. توی این پست میخوایم در مورد مشکلی بحث کنیم که یجورایی برعکس Race condition هست. توی این مشکل، ترد ها منتظر همدیگه میمونن که از یه داده ای استفاده کنن. انقدر منتظر میمونن که عملا هیچکدومشون کاری دیگه انجام نمیده. به این مشکل چی میگن؟ می‌گن Dead Lock." /><link rel="canonical" href="https://www.seedpuller.ir/posts/concurrency-in-cpp-chapter3-3/" /><meta property="og:url" content="https://www.seedpuller.ir/posts/concurrency-in-cpp-chapter3-3/" /><meta property="og:site_name" content="سیدپولر" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2021-04-08T00:00:00+04:30" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="همزمانی در سی++(۳): Dead Lock ها" /><meta name="twitter:site" content="@twitter_username" /><meta name="twitter:creator" content="@سیدپولر" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"author":{"@type":"Person","name":"سیدپولر"},"description":"خب در پست قبل این مسئله که ترد ها برای استفاده از داده باهم مسابقه می‌دن رو کمی بررسی کردیم و یک راه حل دم دست هم براش پیشنهاد دادیم. توی این پست میخوایم در مورد مشکلی بحث کنیم که یجورایی برعکس Race condition هست. توی این مشکل، ترد ها منتظر همدیگه میمونن که از یه داده ای استفاده کنن. انقدر منتظر میمونن که عملا هیچکدومشون کاری دیگه انجام نمیده. به این مشکل چی میگن؟ می‌گن Dead Lock.","url":"https://www.seedpuller.ir/posts/concurrency-in-cpp-chapter3-3/","@type":"BlogPosting","headline":"همزمانی در سی++(۳): Dead Lock ها","dateModified":"2021-04-16T00:31:47+04:30","datePublished":"2021-04-08T00:00:00+04:30","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.seedpuller.ir/posts/concurrency-in-cpp-chapter3-3/"},"@context":"https://schema.org"}</script><title>همزمانی در سی++(۳): Dead Lock ها | سیدپولر</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id="></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', ''); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="https://avatars.githubusercontent.com/u/24620298?s=460&u=dd6165c7d8103164b24d6f40a169594a2c8dac42&v=4" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">سیدپولر</a></div><div class="site-subtitle font-italic">نوشته های مور دانه‌کش</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/SeedPuller" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['SeedPuller','gmail.com'].join('@')" aria-label="email" class="order-4" > <i class="fas fa-envelope"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Posts </a> </span> <span>همزمانی در سی++(۳): Dead Lock ها</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8" style="direction: rtl; text-align: right;"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip style="direction: rtl; text-align: right;">همزمانی در سی++(۳): Dead Lock ها</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Thu, Apr 8, 2021, 12:00 AM +0430" > Apr 8, 2021 <i class="unloaded">2021-04-08T00:00:00+04:30</i> </span> توسط <span class="author"> سیدپولر </span></div><div> <span> بروز شده در <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Fri, Apr 16, 2021, 12:31 AM +0430" > Apr 16, 2021 <i class="unloaded">2021-04-16T00:31:47+04:30</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="حاوی 1205 کلمه"> 6 دقیقه</span></div></div><div class="post-content"><p>خب در پست قبل این مسئله که ترد ها برای استفاده از داده باهم مسابقه می‌دن رو کمی بررسی کردیم و یک راه حل دم دست هم براش پیشنهاد دادیم. توی این پست میخوایم در مورد مشکلی بحث کنیم که یجورایی برعکس Race condition هست. توی این مشکل، ترد ها منتظر همدیگه میمونن که از یه داده ای استفاده کنن. انقدر منتظر میمونن که عملا هیچکدومشون کاری دیگه انجام نمیده. به این مشکل چی میگن؟ می‌گن <em>Dead Lock</em>.</p><h2 id="دِدْلاکdead-lock-چیه-و-چطور-حلش-کنیم">دِدْلاک(Dead Lock) چیه و چطور حلش کنیم</h2><p>اگه بخوام دقیق‌تر توضیح بدم، فرض کنید دوتا mutex داریم که برای انجام یک عملیات نیازمند این هستیم هر دو این میوتکس ها قفل بشن. حالا فرض کنید که دوتا ترد هم داریم که ترد اولی یکی از اون mutex ها و ترد دوم اون یکی mutex رو قفل کردن. نتیجه این میشه که هر دوی این ترد ها منتظر میمونن تا دومین mutex آزاد بشه تا بتونن قفلش کنن و کار خودشون رو انجام بدن. به این ترتیب هیچکدوم از اونها کاری از پیش نمی‌برن.</p><p>اساسا زمانی که بیشتر از یک mutex رو قفل کنیم، احتمال بوجود اومدن ددلاک وجود داره. یک راهی که پیشنهاد میشه اینه که همیشه یک ترتیب خاصی رو در قفل کردن میوتکس ها حفظ کنیم. اگه همیشه اول mutex A رو قفل کنیم و بعدش mutex B رو قفل کنیم، به ددلاک نمیخوریم. اما باز هم مثل بقیه جاهای زندگی، همه چیز انقدرا هم ساده نیست. فرض کنید یک تابع <span dir="ltr"><code class="language-plaintext highlighter-rouge">&lrm;swap(A&amp; a, A&amp;b)</code></span>&rlm; داریم که محتویات a و b رو باهم جابجا می‌کنه. همیشه هم داخل این تابع در ابتدا میوتکس مربوط به آرگومان اولی قفل میشه و سپس میوتکس آرگومان دومی قفل میشه. آیا دیگه Dead Lock نخواهیم داشت؟ نخیر! خواهیم داشت. فرض کنید دوتا ترد داشته باشیم که همزمان سعی کنن محتوای دوتا شئ رو باهم عوض کنن؛ فقط با ترتیب برعکس (:</p><div class="language-cpp highlighter-rouge"><div class="highlight" style="direction: ltr; text-align: left;"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">swap</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="c1">// thread 1</span>
<span class="n">swap</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span> <span class="c1">// thread 2</span>
</pre></table></code></span>&rlm;</div></div><p>همین برای یه ددلاک نا زیبا کافیه (:</p><p>خوشبختانه دوستان ما در کتابخانه استاندارد همچین چیزی رو پیش‌بینی کردن و برامون <span dir="ltr"><code class="language-plaintext highlighter-rouge">&lrm;std::lock</code></span>&rlm; (و در استاندارد ۱۷ به بعد که مورد علاقه من هم هست <span dir="ltr"><code class="language-plaintext highlighter-rouge">&lrm;scoped_lock</code></span>&rlm; )رو درست کردن. این تابع می‌تونه دوتا ‌میوتکس رو به شکل همزمان قفل کنه و اگه یکی از میوتکس ها آزاد نباشه، بلافاصله اون یکی رو آزاد می‌کنه. یعنی اینطوری که: یا هردو یا هیچکدوم!</p><div class="language-cpp highlighter-rouge"><div class="highlight" style="direction: ltr; text-align: left;"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">some_big_object</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="n">some_big_object</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span><span class="n">some_big_object</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">);</span>
<span class="k">class</span> <span class="nc">X</span>
<span class="p">{</span>
<span class="nl">private:</span>
    <span class="n">some_big_object</span> <span class="n">some_detail</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">m</span><span class="p">;</span>
<span class="nl">public:</span>
    <span class="n">X</span><span class="p">(</span><span class="n">some_big_object</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">sd</span><span class="p">)</span><span class="o">:</span><span class="n">some_detail</span><span class="p">(</span><span class="n">sd</span><span class="p">){}</span>
    <span class="k">friend</span> <span class="kt">void</span> <span class="n">swap</span><span class="p">(</span><span class="n">X</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">X</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lhs</span><span class="o">==&amp;</span><span class="n">rhs</span><span class="p">)</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">lock</span><span class="p">(</span><span class="n">lhs</span><span class="p">.</span><span class="n">m</span><span class="p">,</span><span class="n">rhs</span><span class="p">.</span><span class="n">m</span><span class="p">);</span>
        <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock_a</span><span class="p">(</span><span class="n">lhs</span><span class="p">.</span><span class="n">m</span><span class="p">,</span><span class="n">std</span><span class="o">::</span><span class="n">adopt_lock</span><span class="p">);</span>
        <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock_b</span><span class="p">(</span><span class="n">rhs</span><span class="p">.</span><span class="n">m</span><span class="p">,</span><span class="n">std</span><span class="o">::</span><span class="n">adopt_lock</span><span class="p">);</span>
        <span class="c1">// 3 lines above could brief in: scoped_lock(lhs.m, rhs.m)</span>
        <span class="n">swap</span><span class="p">(</span><span class="n">lhs</span><span class="p">.</span><span class="n">some_detail</span><span class="p">,</span><span class="n">rhs</span><span class="p">.</span><span class="n">some_detail</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></span>&rlm;</div></div><h2 id="راه-های-دیگه">راه های دیگه</h2><h3 id="از-قفل-کردن-های-تو-در-تو-بپرهیزید">از قفل کردن های تو در تو بپرهیزید</h3><p>مسئله ساده‌ست. اول اینکه سعی کنید تا جای ممکن بیشتر از یدونه mutex رو قفل نکنید. اگر مجبور بودیم، حداقل میوتکس ها رو به صورت همزمان- حالا با استفاده از <span dir="ltr"><code class="language-plaintext highlighter-rouge">&lrm;std::lock</code></span>&rlm; یا <span dir="ltr"><code class="language-plaintext highlighter-rouge">&lrm;std::scoped_lock</code></span>&rlm; )- قفل کنید.</p><h3 id="قفل-کردن-با-ترتیب-معین-و-مشخص">قفل کردن با ترتیب معین و مشخص</h3><p>قبل تر هم گفتم، اگه با ترتیب خاصی این قفل کردن رو انجام بدیم با تقریب خوبی زیاد به مشکل نمی‌خوریم. اگه مجبوریم دوتا میوتکس رو جدا جدا قفل کنیم، بهتره که ترتیبشون رو در همه جا رعایت بکنیم. ولی خب اینکار هم نیازمند مراقبت های دیگه‌ست. به عنوان مثال یک لیست دو پیوندی رو در نظر بگیرید. برای پیمایش این لیست ما میایم و هر گره ای که میخوایم بخونیم رو قفل می‌کنیم و برای حرکت کردن هم میایم گره بعدی/قبلی رو قفل می‌کنیم و گره فعلی رو آزاد می‌کنیم. اینجا هم مشکل هست. اگر دوتا ترد به شکل همزمان ولی با جهت عکس همدیگه(یعنی یکی از اول لیست بره آخر و اون یکی برعکس) شروع به پیمایش لیست بکنن، در وسط لیست به dead lock میخورن. راه حل اینه که یک محدودیت اضافی بذاریم که فقط یکی از نحوات پیمایش کردن مجاز باشه :) پس باید حواسمون به خیلی چیزا باشه.</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://mark.nl.tab.digital/s/Ejd85qkYcKAAP84/preview" alt="picture" class="normal" /> <em>اگه در این وضعیت دوتا ترد مخالف جهت همدیگه شروع به حرکتت کنن،‌ ددلاک خواهیم داشت</em></p><h3 id="استفاده-از-قفل-های-سلسلهمراتبی">استفاده از قفل های سلسله‌مراتبی</h3><p>ایده کلی‌ش تقریبا همون راه قبلیه فقط با این تفاوت که میایم و یک Lock hierarchy درست می‌کنیم که بیاد در runtime چک کنه که آیا ترتیب قفل شدن میوتکس ها صحیحه یا نه. اینطوری کمتر نیاز داریم که «خودمون حواسمون جمع باشه که ترتیب رو رعایت کنیم».</p><p>حالا این ایده چطوری کار می‌کنه؟ اینطوری که میایم و برنامه‌مون رو به لایه های مختلف تقسیم می‌کنیم و مشخص می‌کنیم که هر میوتکس مربوط به کدوم لایه‌ست. قانون قفل کردن رو هم اینطوری قرار می‌دیم که فقط از بالا به پایین امکان قفل کردن وجود داشته باشه. یعنی اگر فرض کنیم لایه ۱ بالای لایه ۲ و لایه ۲ هم بالای لایهٔ ۳ قرار داشته باشه و الی آخر، فقط تنها زمانی می‌تونیم مثلا لایه ۲ رو قفل کنیم که لایه های پایین ترش آزاد باشن. بنابراین فقط می‌تونیم از بالا به پایین حرکت کنیم.</p><div class="language-cpp highlighter-rouge"><div class="highlight" style="direction: ltr; text-align: left;"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
</pre><td class="rouge-code"><pre><span class="n">hierarchical_mutex</span> <span class="nf">high_level_mutex</span><span class="p">(</span><span class="mi">10000</span><span class="p">);</span>
<span class="n">hierarchical_mutex</span> <span class="nf">low_level_mutex</span><span class="p">(</span><span class="mi">5000</span><span class="p">);</span>
<span class="n">hierarchical_mutex</span> <span class="nf">other_mutex</span><span class="p">(</span><span class="mi">6000</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">do_low_level_stuff</span><span class="p">();</span>
<span class="kt">int</span> <span class="nf">low_level_func</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">hierarchical_mutex</span><span class="o">&gt;</span> <span class="n">lk</span><span class="p">(</span><span class="n">low_level_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">do_low_level_stuff</span><span class="p">();</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">high_level_stuff</span><span class="p">(</span><span class="kt">int</span> <span class="n">some_param</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">high_level_func</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">hierarchical_mutex</span><span class="o">&gt;</span> <span class="n">lk</span><span class="p">(</span><span class="n">high_level_mutex</span><span class="p">);</span>
	<span class="n">high_level_stuff</span><span class="p">(</span><span class="n">low_level_func</span><span class="p">());</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">thread_a</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">high_level_func</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">do_other_stuff</span><span class="p">();</span>
<span class="kt">void</span> <span class="nf">other_stuff</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">high_level_func</span><span class="p">();</span>
	<span class="n">do_other_stuff</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">thread_b</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">hierarchical_mutex</span><span class="o">&gt;</span> <span class="n">lk</span><span class="p">(</span><span class="n">other_mutex</span><span class="p">);</span>
	<span class="n">other_stuff</span><span class="p">();</span>
<span class="p">}</span>

</pre></table></code></span>&rlm;</div></div><p>کد بالا نمونه استفاده از یک میوتکس سلسله مراتبی یا hierarchical mutex هست. ترد a بدون مشکل می‌تونه به کارش ادامه بده چون میوتکس هاش رو با رعایت قوانین(که بالاتر ذکر کردم) قفل می‌کنه. اما ترد b به مشکل میخوره. چرا؟ چون اول اومده <span dir="ltr"><code class="language-plaintext highlighter-rouge">&lrm;other_mutex</code></span>&rlm; که عددش برابر با 6000 هست رو قفل کرده. بعدش چی؟ بعدش در تابع <span dir="ltr"><code class="language-plaintext highlighter-rouge">&lrm;other_stuff()</code></span>&rlm; اومده و یک میوتکس با عدد 10000 رو قفل کرده. و این مشخصا خلاف قوانینی که گفتیمه چرا که ترد ها فقط میتونن ترد هایی با عدد کمتر از عدد فعلی رو قفل کنن و برعکسش امکان پذیر نیست. به همین شکل، ترتیب قفل کردن ترد ها رعایت می‌شه (:</p><p>البته این روش هم مشکلاتی داره… به عنوان مثال برای پیمایش یک لیست که نیازمند دست به دست کردن یا hand-over-hand کردن قفلِ میوتکس ها هست، جواب نمیده برای اینکه اونوقت به تعداد گره های لیست نیاز به سطح/لایه/… داریم! :/</p><h2 id="storage-class-specifier-thread_local">Storage class specifier: <span dir="ltr"><code class="language-plaintext highlighter-rouge">&lrm;thread_local</code></span>&rlm;</h2><p>اگه بخوایم یه متغییری داشته باشیم که به ازای هر «ترد» ازش ساخته بشه، از این مشخصه استفاده می‌کنیم.</p><div class="language-cpp highlighter-rouge"><div class="highlight" style="direction: ltr; text-align: left;"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">thread_local</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> 
</pre></table></code></span>&rlm;</div></div><p>فرض کنیم دو ترد به اسم a و b داریم. اگر مقدار <span dir="ltr"><code class="language-plaintext highlighter-rouge">&lrm;value</code></span>&rlm; در ترد a برابر با ۲ بشه، همه اونهایی که در ترد a هستن مقدار ۲ رو می‌بینن ولی مقدار <span dir="ltr"><code class="language-plaintext highlighter-rouge">&lrm;value</code></span>&rlm; در ترد b همون ۱ هست و تغییری نمی‌کنه. بنابراین، این نوع متغییر ها فقط به ازای هر ترد براشون حافظه تخصیص داده می‌شه و در پایان کار هر ترد هم از بین می‌رن.</p><h2 id="پایان">پایان</h2><p>بحث دِدلاک هم تقریبا فهمیدیم چیه و چطور میشه ازش جلوگیری کرد. متاسفانه دوباره دارم برمیگردم به اون حالت هیچکاری نکردن و عقب موندن از همه کارهام. از این وضعیت خوشم نمیاد. سعی می‌کنم تغییرش بدم.</p><p>در پست بعدی درباره اینکه چطور با میوتکس ها می‌تونیم ژانگولر بازی در بیاریم صحبت می‌کنیم.</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/%D8%B3%DB%8C/'>سی++</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/c/" class="post-tag no-text-decoration" >C++</a> <a href="/tags/concurrency-in-action/" class="post-tag no-text-decoration" >concurrency in action</a> <a href="/tags/concurrent-processing/" class="post-tag no-text-decoration" >concurrent processing</a> <a href="/tags/%D9%85%D9%88%D8%A7%D8%B2%DB%8C-%DA%A9%D8%A7%D8%B1%DB%8C/" class="post-tag no-text-decoration" >موازی کاری</a> <a href="/tags/%D9%87%D9%85%D8%B2%D9%85%D8%A7%D9%86%DB%8C/" class="post-tag no-text-decoration" >همزمانی</a> <a href="/tags/%D8%B3%DB%8C/" class="post-tag no-text-decoration" >سی++</a> <a href="/tags/%D8%B3%DB%8C-%DB%B1%DB%B7/" class="post-tag no-text-decoration" >سی++۱۷</a> <a href="/tags/shared-data/" class="post-tag no-text-decoration" >shared data</a> <a href="/tags/mutex/" class="post-tag no-text-decoration" >mutex</a> <a href="/tags/std-mutex/" class="post-tag no-text-decoration" >std::mutex</a> <a href="/tags/%D9%85%DB%8C%D9%88%D8%AA%DA%A9%D8%B3/" class="post-tag no-text-decoration" >میوتکس</a> <a href="/tags/dead-lock/" class="post-tag no-text-decoration" >Dead Lock</a> <a href="/tags/%D8%AF%D8%AF%D9%84%D8%A7%DA%A9/" class="post-tag no-text-decoration" >ددلاک</a> <a href="/tags/std-lock/" class="post-tag no-text-decoration" >std::lock</a> <a href="/tags/std-scoped-lock/" class="post-tag no-text-decoration" >std::scoped_lock</a> <a href="/tags/thread-local/" class="post-tag no-text-decoration" >thread_local</a> <a href="/tags/storage-class-specifier/" class="post-tag no-text-decoration" >Storage class specifier</a> <a href="/tags/thread/" class="post-tag no-text-decoration" >thread</a> <a href="/tags/multithread/" class="post-tag no-text-decoration" >multithread</a> <a href="/tags/multi-thread/" class="post-tag no-text-decoration" >multi thread</a> <a href="/tags/multi-threading/" class="post-tag no-text-decoration" >multi threading</a> <a href="/tags/%DA%86%D9%86%D8%AF-%D9%86%D8%AE%DB%8C/" class="post-tag no-text-decoration" >چند نخی</a> <a href="/tags/%D8%A8%D8%B1%D9%86%D8%A7%D9%85%D9%87-%D9%86%D9%88%DB%8C%D8%B3%DB%8C-%DA%86%D9%86%D8%AF-%D9%86%D8%AE%DB%8C/" class="post-tag no-text-decoration" >برنامه نویسی چند نخی</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> این پست تحت مجوز <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> منتشر شده است.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">اشتراک گذاری</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=همزمانی در سی++(۳): Dead Lock ها - سیدپولر&url=https://www.seedpuller.ir/posts/concurrency-in-cpp-chapter3-3/" data-toggle="tooltip" data-placement="top" title="توئیتر" target="_blank" rel="noopener" aria-label="توئیتر"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://telegram.me/share?text=همزمانی در سی++(۳): Dead Lock ها - سیدپولر&url=https://www.seedpuller.ir/posts/concurrency-in-cpp-chapter3-3/" data-toggle="tooltip" data-placement="top" title="تلگرام" target="_blank" rel="noopener" aria-label="تلگرام"> <i class="fa-fw fab fa-telegram"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="کپی لینک پست"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/concurrency-in-cpp-chapter1/">همزمانی در سی++: مفاهیم اولیه</a><li><a href="/posts/concurrency-in-cpp-chapter3-5/">همزمانی در سی++(۵): جایگزین های mutex</a><li><a href="/posts/concurrency-in-cpp-chapter3-3/">همزمانی در سی++(۳): Dead Lock ها</a><li><a href="/posts/concurrency-in-cpp-chapter3-4/">همزمانی در سی++(۴): ژانگولر بازی با mutex و کارهای دیگر</a><li><a href="/posts/concurrency-in-cpp-chapter3-1/">همزمانی در سی++: اشتراک گذاری داده ها(۱)</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/c/">C++</a> <a class="post-tag" href="/tags/%D8%B3%DB%8C/">سی++</a> <a class="post-tag" href="/tags/inner-struggle/">Inner Struggle</a> <a class="post-tag" href="/tags/%D8%AF%D8%A7%DB%8C%D8%AA%D9%84/">دایتل</a> <a class="post-tag" href="/tags/%DB%8C%D8%A7%D8%AF%DA%AF%DB%8C%D8%B1%DB%8C/">یادگیری</a> <a class="post-tag" href="/tags/concurrency-in-action/">concurrency in action</a> <a class="post-tag" href="/tags/concurrent-processing/">concurrent processing</a> <a class="post-tag" href="/tags/%D8%A8%D8%B1%D9%86%D8%A7%D9%85%D9%87-%D9%86%D9%88%DB%8C%D8%B3%DB%8C-%DA%86%D9%86%D8%AF-%D9%86%D8%AE%DB%8C/">برنامه نویسی چند نخی</a> <a class="post-tag" href="/tags/%D8%B3%DB%8C-%DB%B1%DB%B7/">سی++۱۷</a> <a class="post-tag" href="/tags/%D9%85%D9%88%D8%A7%D8%B2%DB%8C-%DA%A9%D8%A7%D8%B1%DB%8C/">موازی کاری</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/concurrency-in-cpp-chapter1/"><div class="card-body"> <span class="timeago small" > Sep 24, 2020 <i class="unloaded">2020-09-24T00:00:00+03:30</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>همزمانی در سی++: مفاهیم اولیه</h3><div class="text-muted small"><p> بالاخره شروع کردم به خوندن کتاب C++ Concurrency in action نوشته Anthony Williams. این کتاب رو باید یک ماه پیش تموم می‌کردم اما مثل همیشه خیلی کند پیش رفتم و فقط ۲ فصلش رو تا الآن خوندم و تازه دارم...</p></div></div></a></div><div class="card"> <a href="/posts/concurrency-in-cpp-chapter3-4/"><div class="card-body"> <span class="timeago small" > Apr 12, 2021 <i class="unloaded">2021-04-12T00:00:00+04:30</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>همزمانی در سی++(۴): ژانگولر بازی با mutex و کارهای دیگر</h3><div class="text-muted small"><p> در این پست درباره اینکه چطور می‌تونیم یک سری ژانگولر بازی با mutex ها دربیاریم صحبت می‌کنیم. مثلا چطور میوتکس ها رو بین scope ها جابجا کنیم، یا چطور با انعطاف بیشتری نسبت به قفل کردن mutex ها اقدام...</p></div></div></a></div><div class="card"> <a href="/posts/concurrency-in-cpp-chapter3-5/"><div class="card-body"> <span class="timeago small" > Apr 18, 2021 <i class="unloaded">2021-04-18T00:00:00+04:30</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>همزمانی در سی++(۵): جایگزین های mutex</h3><div class="text-muted small"><p> در پست قبل درباره اینکه چه کار های دیگه‌ای میشه با mutex ها انجام داد صحبت کردیم و همچنین کلاس std::unique_ptr رو معرفی کردیم که دست ما رو برای استفاده از mutex ها باز می‌کنه. در این پست قراره که ج...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/concurrency-in-cpp-chapter3-2/" class="btn btn-outline-primary" prompt="قبلی"><p>همزمانی در سی++: اشتراک گذاری داده ها(۲)</p></a> <a href="/posts/Inner-Struggle4/" class="btn btn-outline-primary" prompt="بعدی"><p>یادداشت بداهه۴</p></a></div></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('.post-content img'); const observer = lozad(imgs); observer.observe(); </script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div><div class="footer-right" style="direction: rtl; text-align: right;"><p class="mb-0"> <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">مطالب این وبسایت تحت مجوز CC-BY-4.0 منتشر می‌شوند</span></p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/c/">C++</a> <a class="post-tag" href="/tags/%D8%B3%DB%8C/">سی++</a> <a class="post-tag" href="/tags/inner-struggle/">Inner Struggle</a> <a class="post-tag" href="/tags/%D8%AF%D8%A7%DB%8C%D8%AA%D9%84/">دایتل</a> <a class="post-tag" href="/tags/%DB%8C%D8%A7%D8%AF%DA%AF%DB%8C%D8%B1%DB%8C/">یادگیری</a> <a class="post-tag" href="/tags/concurrency-in-action/">concurrency in action</a> <a class="post-tag" href="/tags/concurrent-processing/">concurrent processing</a> <a class="post-tag" href="/tags/%D8%A8%D8%B1%D9%86%D8%A7%D9%85%D9%87-%D9%86%D9%88%DB%8C%D8%B3%DB%8C-%DA%86%D9%86%D8%AF-%D9%86%D8%AE%DB%8C/">برنامه نویسی چند نخی</a> <a class="post-tag" href="/tags/%D8%B3%DB%8C-%DB%B1%DB%B7/">سی++۱۷</a> <a class="post-tag" href="/tags/%D9%85%D9%88%D8%A7%D8%B2%DB%8C-%DA%A9%D8%A7%D8%B1%DB%8C/">موازی کاری</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://www.seedpuller.ir{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
