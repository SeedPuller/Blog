<!DOCTYPE html><html lang="fa-IR" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="pv-cache-enabled" content="false"><meta name="generator" content="Jekyll v4.2.0" /><meta property="og:title" content="نکات جدیدی که از فصل ۱۵ دایتل یاد گرفتم – کتابخانه استاندارد" /><meta name="author" content="سیدپولر" /><meta property="og:locale" content="fa_IR" /><meta name="description" content="توی این فصل سه بخش از کتابخانه استاندارد سی++ که بهش STL هم میگن رو بررسی می‌کنیم. container ها، iterator ها و algorithm ها. فصل بسیار مهمیه چراکه این کتابخونه بسیاری از کار های مارو راحت تر می‌کنه و اگر خوب بلد باشیم ازش استفاده کنیم، دهن خودمون رو برای پیاده سازی کردن خیلی از چیز ها صاف نمی‌کنیم." /><meta property="og:description" content="توی این فصل سه بخش از کتابخانه استاندارد سی++ که بهش STL هم میگن رو بررسی می‌کنیم. container ها، iterator ها و algorithm ها. فصل بسیار مهمیه چراکه این کتابخونه بسیاری از کار های مارو راحت تر می‌کنه و اگر خوب بلد باشیم ازش استفاده کنیم، دهن خودمون رو برای پیاده سازی کردن خیلی از چیز ها صاف نمی‌کنیم." /><link rel="canonical" href="https://www.seedpuller.ir/posts/what-ive-learned-from-deitel-chapter-15/" /><meta property="og:url" content="https://www.seedpuller.ir/posts/what-ive-learned-from-deitel-chapter-15/" /><meta property="og:site_name" content="سیدپولر" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2020-07-21T00:00:00+04:30" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="نکات جدیدی که از فصل ۱۵ دایتل یاد گرفتم – کتابخانه استاندارد" /><meta name="twitter:site" content="@twitter_username" /><meta name="twitter:creator" content="@سیدپولر" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"author":{"@type":"Person","name":"سیدپولر"},"description":"توی این فصل سه بخش از کتابخانه استاندارد سی++ که بهش STL هم میگن رو بررسی می‌کنیم. container ها، iterator ها و algorithm ها. فصل بسیار مهمیه چراکه این کتابخونه بسیاری از کار های مارو راحت تر می‌کنه و اگر خوب بلد باشیم ازش استفاده کنیم، دهن خودمون رو برای پیاده سازی کردن خیلی از چیز ها صاف نمی‌کنیم.","url":"https://www.seedpuller.ir/posts/what-ive-learned-from-deitel-chapter-15/","@type":"BlogPosting","headline":"نکات جدیدی که از فصل ۱۵ دایتل یاد گرفتم – کتابخانه استاندارد","dateModified":"2020-07-21T00:00:00+04:30","datePublished":"2020-07-21T00:00:00+04:30","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.seedpuller.ir/posts/what-ive-learned-from-deitel-chapter-15/"},"@context":"https://schema.org"}</script><title>نکات جدیدی که از فصل ۱۵ دایتل یاد گرفتم – کتابخانه استاندارد | سیدپولر</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id="></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', ''); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="https://avatars.githubusercontent.com/u/24620298?s=460&u=dd6165c7d8103164b24d6f40a169594a2c8dac42&v=4" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">سیدپولر</a></div><div class="site-subtitle font-italic">نوشته های مور دانه‌کش</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/SeedPuller" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['SeedPuller','gmail.com'].join('@')" aria-label="email" class="order-4" > <i class="fas fa-envelope"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Posts </a> </span> <span>نکات جدیدی که از فصل ۱۵ دایتل یاد گرفتم – کتابخانه استاندارد</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8" style="direction: rtl; text-align: right;"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip style="direction: rtl; text-align: right;">نکات جدیدی که از فصل ۱۵ دایتل یاد گرفتم – کتابخانه استاندارد</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Tue, Jul 21, 2020, 12:00 AM +0430" > Jul 21, 2020 <i class="unloaded">2020-07-21T00:00:00+04:30</i> </span> توسط <span class="author"> سیدپولر </span></div><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="حاوی 1514 کلمه"> 8 دقیقه</span></div></div><div class="post-content"><p>توی این فصل سه بخش از کتابخانه استاندارد سی++ که بهش STL هم میگن رو بررسی می‌کنیم. container ها، iterator ها و algorithm ها. فصل بسیار مهمیه چراکه این کتابخونه بسیاری از کار های مارو راحت تر می‌کنه و اگر خوب بلد باشیم ازش استفاده کنیم، دهن خودمون رو برای پیاده سازی کردن خیلی از چیز ها صاف نمی‌کنیم.</p><h2 id="کانتینر-ها">کانتینر ها</h2><p>کانتینر ها یک ساختمان داده ای هستند که تقریبا میشه همه نوع داده ای رو توشون ذخیره کرد. درکل سه نوع کانتینر داریم که به شکل زیر دسته بندی میشن:</p><ul><li>first class containers<li>container adapters<li>near containers</ul><p>یک نوع دسته بندی دیگه هم وجود داره که کانتینر هارو به ۴ بخش تقسیم می‌کنه:</p><ul><li>Sequence containers<li>Ordered associative containers<li>unordered associative containers<li>container adapters</ul><p>بخش sequence containers و associative containers درواقع به عنوان first class container در نظر گرفته میشن.</p><p>container adapter در اصل همون first class container ها هستن که عملیات هاشون محدود شده. این کانتینر شامل استک، صف و … هست.</p><p>یک نوع کانتینر دیگه هم داریم که بهشون میگن near containers. دلیل اینکه اسمشون رو به این شکل انتخاب کردن اینه که این کانتینر ها بعضی از قابلیت های first-class container هارو دارن و بخش دیگه ایشون رو ندارن. مثالی که میشه از این کانتینر ها زد؟ built-in array ها، کلاس های مربوط به <span dir="ltr"><code class="language-plaintext highlighter-rouge">&lrm;bitset</code></span>&rlm; و <span dir="ltr"><code class="language-plaintext highlighter-rouge">&lrm;valarray</code></span>&rlm; ها(که برای انجام عملیات های سریع ریاضی روی وکتور ها* بکار میره) و …</p><p>*اون وکتور، با <span dir="ltr"><code class="language-plaintext highlighter-rouge">&lrm;vector</code></span>&rlm; ای که توی کانتینر ها داریم فرق داره.</p><p>توی جدول زیر میتونیم لیست کانتینر ها و ویژگی‌هاشون رو ببینیم که خیلی جالبه:<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://seedpuller.space/wp-content/uploads/2020/07/image.png" alt="" /></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://seedpuller.space/wp-content/uploads/2020/07/image-1.png" alt="" /></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://seedpuller.space/wp-content/uploads/2020/07/image-2.png" alt="" /></p><h4 id="نکاتی-درباره-پرفورمنس-کانتینر-ها">نکاتی درباره پرفورمنس کانتینر ها</h4><ul><li>اضافه/حذف کردن به/از آخر vector ها سریعه. اما اضافه/حذف کردن به/از اول و یا وسط vector ها به صرفه نیست<li>اگر نیاز داریم که صورت مفرط به ابتدا/انتها کانتینرمون المان اضافه(یا حذف) بکنیم بهتره از deque (تلفظ میشه دِکْ) استفاده بکنیم چرا که عملیات هاش در ابتدا و انتهای کانتینر سریعن<li>در آخر اگه نیاز داریم که در وسط کانتینر هم چیزی رو حذف کنیم یا اضافه کنیم، بهتره از list استفاده بکنیم.</ul><p><strong>Sequence Container ها:</strong></p><h3 id="وکتور-ها-vector">وکتور ها (<span dir="ltr"><code class="language-plaintext highlighter-rouge">&lrm;vector</code></span>&rlm; )</h3><p>وکتور کانتینری هست که از خونه های متوالی حافظه استفاده میکنه. در واقع در لایه های زیرین وکتور میاد و با یک اندازه ثابت یک آرایه تخصیص میده. بعد از پر شدن آرایه، یک آرایه با اندازهٔ بیشتر از حافظه میگیره و اطلاعات آرایه قبلی رو در آرایه جدید کپی میکنه(یا move میکنه) و آرایه قبلی رو حذف می‌کنه. در واقع این قابلیت آرایه بودن این امکان رو بهش میده که بشه به صورت آنی به المان های وکتور دسترسی پیدا کرد.</p><p>اگر می‌دونیم که حدودا قراره چه مقدار داده به وکتور اضافه کنیم، بهتره با استفاده از توابع resize یا reserve اون حافظه رو برای وکتور بگیریم تا از تخصیص و حذف پی در پی حافظه جلوگیری کنیم. C++11: shrink_to_fit</p><p>اینکه چطور یک وکتور اقدام به افزایش حافظه میکنه بستگی به پیاده سازی داره و ممکنه توی کامپایلر های مختلف، نتیجهٔ متفاوتی داشته باشه. در حالت کلی این یک time-space tradeoff هست.</p><h4 id="فرق-بین-clear-و-erase">فرق بین <span dir="ltr"><code class="language-plaintext highlighter-rouge">&lrm;clear</code></span>&rlm; و <span dir="ltr"><code class="language-plaintext highlighter-rouge">&lrm;erase</code></span>&rlm;</h4><p>فرق این دو این هست که تابع clear کل اعضای وکتور رو پاک میکنه اما erase این قابلیت رو داره که تک عضو و یا یک رنج از عضو ها رو از وکتور پاک کنه.</p><h3 id="لیست-ها-list">لیست ها (<span dir="ltr"><code class="language-plaintext highlighter-rouge">&lrm;list</code></span>&rlm; )</h3><p>لیست که درواقع یک لیست دو پیوندی هست (doubly linked list) اجازهٔ اضافه و حذف کردن سریع در هر جای کانتینر رو میده اما در حالت کلی اگر بیشتر عملیات هامون قراره در دو انتهای کانتینر باشه، بهتره که از دِک (deque) استفاده کنیم.</p><h4 id="تابع-unique">تابع <span dir="ltr"><code class="language-plaintext highlighter-rouge">&lrm;unique</code></span>&rlm;</h4><p>این تابع عناصر تکراری یه کانتینر رو حذف می‌کنه. البته برای اینکه درست کار کنه کانتینر ما از قبل باید سورت شده باشه تا عناصر تکراری کنار هم قرار بگیرن.</p><h3 id="دِک-ها-deque">دِک ها (<span dir="ltr"><code class="language-plaintext highlighter-rouge">&lrm;deque</code></span>&rlm; )</h3><p>کلاس دک درواقع نکات مثبت وکتور و لیست رو توی خودش جمع کرده. کلمهٔ deque کوتاه شدهٔ double-ended queue هست. این کلاس قابلیت دسترسی سریع و مستقیم به عناصر داره و همچنین عملیات هایی که در دو سمت انتهایی این کانتینر انجام میشن سریعن.</p><p>از اونجایی که از random-access iterator ها ساپورت میکنه بنابراین همهٔ الگوریتم های کتابخونه استاندارد میتونن روی این کلاس اعمال بشن.</p><p>در حالت کلی دک سربار بیشتری از وکتور داره و همچنین حذف و اضافه کردن در وسط دک ها بهینه تر از وکتوره(همچنان کند تر از لیست ها)</p><p><strong>حالا که یک دید کلی از Sequence container ها داریم، به Associative Container ها می‌پردازیم:</strong></p><p>این کانتینر ها قابلیت این رو به ما میدن که با استفاده از یک کلید بتونیم به صورت مستقیم به مقادیر مورد نظرمون دسترسی داشته باشیم. ۸ نوع کلاس وجود داره که ۴ تای اول کلید هارو به صورت مرتب ذخیره میکنن و ۴ تای دوم، ترتیب کلید ها براشون مهم نیست.</p><ul><li><span dir="ltr"><code class="language-plaintext highlighter-rouge">&lrm;multiset</code></span>&rlm; , <span dir="ltr"><code class="language-plaintext highlighter-rouge">&lrm;set</code></span>&rlm; , <span dir="ltr"><code class="language-plaintext highlighter-rouge">&lrm;multimap</code></span>&rlm; , <span dir="ltr"><code class="language-plaintext highlighter-rouge">&lrm;map</code></span>&rlm;<li><span dir="ltr"><code class="language-plaintext highlighter-rouge">&lrm;unordered_multiset</code></span>&rlm; , <span dir="ltr"><code class="language-plaintext highlighter-rouge">&lrm;unordered_set</code></span>&rlm; , <span dir="ltr"><code class="language-plaintext highlighter-rouge">&lrm;unordered_multimap</code></span>&rlm; , <span dir="ltr"><code class="language-plaintext highlighter-rouge">&lrm;unordered_map</code></span>&rlm;</ul><p>کلاس های <span dir="ltr"><code class="language-plaintext highlighter-rouge">&lrm;set</code></span>&rlm; و <span dir="ltr"><code class="language-plaintext highlighter-rouge">&lrm;multiset</code></span>&rlm; به ما یه مجموعه ای از مقادیر رو میدن که خود اون مقدار ها، کلید هم هستن. فرق اصلی این دو کلاس اینه که کلاس <span dir="ltr"><code class="language-plaintext highlighter-rouge">&lrm;set</code></span>&rlm; اجازه نمیده مقادیر تکراری به مجموعه اضافه بشن اما کلاس <span dir="ltr"><code class="language-plaintext highlighter-rouge">&lrm;multiset</code></span>&rlm; این اجازه رو میده.</p><p>کلاس های <span dir="ltr"><code class="language-plaintext highlighter-rouge">&lrm;map</code></span>&rlm; و <span dir="ltr"><code class="language-plaintext highlighter-rouge">&lrm;multimap</code></span>&rlm; یه مجموعه به ما میدن که هر کلید، به یک مقدار وصله. فرقشون هم اینه که در کلاس <span dir="ltr"><code class="language-plaintext highlighter-rouge">&lrm;map</code></span>&rlm; نمیشه یک کلید چند مقدار متفاوت داشته باشه اما این امر توی <span dir="ltr"><code class="language-plaintext highlighter-rouge">&lrm;multimap</code></span>&rlm; امکان پذیره.</p><h3 id="کلاس-multiset">کلاس <span dir="ltr"><code class="language-plaintext highlighter-rouge">&lrm;multiset</code></span>&rlm;</h3><p>این کلاس که از هدر <span dir="ltr"><code class="language-plaintext highlighter-rouge">&lrm;&lt;set&gt;</code></span>&rlm; میتونیم بهش دسترسی داشته باشیم به ما قابلیت ذخیره سازی و بازیابی سریع مقادیر رو میده همچنین قابلیت این رو داره مقادیر تکراری رو ذخیره کنه. این کلاس برای مرتب کردن عناصرش از چیزی به نام <em>comparator function object</em> استفاده می‌کنه که توی فصل بعد بهش می‌پردازیم. اگر ترتیب مقدار ها مهم نیست بهتره که از <span dir="ltr"><code class="language-plaintext highlighter-rouge">&lrm;unordered_multiset</code></span>&rlm; استفاده بکنیم چراکه سربار کمتری داره(هدر<span dir="ltr"><code class="language-plaintext highlighter-rouge">&lrm;&lt;unordered_set&gt;</code></span>&rlm; ) . مثال برای استفاده از multiset:</p><div class="language-cpp highlighter-rouge"><div class="highlight" style="direction: ltr; text-align: left;"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">std</span><span class="o">::</span><span class="n">multiset</span> <span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">less</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">values</span><span class="p">;</span>
</pre></table></code></span>&rlm;</div></div><p>که در اینجا اون <span dir="ltr"><code class="language-plaintext highlighter-rouge">&lrm;less&lt;int&gt;</code></span>&rlm; یک comparator function object هست(اختیاری) و باعث میشه مقادیر ما به صورت صعودی مرتب بشن.</p><h3 id="کلاس-set">کلاس <span dir="ltr"><code class="language-plaintext highlighter-rouge">&lrm;set</code></span>&rlm;</h3><p>این کلاس تنها فرقی که با <span dir="ltr"><code class="language-plaintext highlighter-rouge">&lrm;multiset</code></span>&rlm; داره اینه که عناصر تکراری رو ignore میکنه و درواقع همهٔ عناصر موجود در اون، یکتا هستن.</p><h3 id="کلاس-multimap">کلاس <span dir="ltr"><code class="language-plaintext highlighter-rouge">&lrm;multimap</code></span>&rlm;</h3><p>این نوع از associative container که از طریق هدر <span dir="ltr"><code class="language-plaintext highlighter-rouge">&lrm;map</code></span>&rlm; میشه بهش دسترسی داشت به ما این قابلیت رو میده که مقادیر رو به صورت «جفت» (pair) ذخیره کنیم. یعنی اینکه به ازای هر مقدار، یک کلید وجود داره. اینکه کلید ها به چه ترتیبی مرتب بشن رو میشه از طریق comparator function ها تعیین کرد. کلاس <span dir="ltr"><code class="language-plaintext highlighter-rouge">&lrm;multimap</code></span>&rlm; اجازه میده که کلید های تکراری داشته باشیم یعنی یک کلید میتونه چندین مقدار داشته باشه که بهش میگن <em>one-to-many relationship</em> و احتمالا بخاطر همینه که برای این کلاس random-access iterator نذاشتن.</p><h3 id="کلاس-map">کلاس <span dir="ltr"><code class="language-plaintext highlighter-rouge">&lrm;map</code></span>&rlm;</h3><p>این کلاس شبیه <span dir="ltr"><code class="language-plaintext highlighter-rouge">&lrm;multimap</code></span>&rlm; عه تنها با این تفاوت که امکان وجود کلید تکراری نیست. یعنی هر کلید فقط به یک مقدار اشاره میکنه (<em>one-to-one mapping</em>) و همچنین این قابلیت وجود داره که به مقدار هر کلید به صورت آنی دسترسی داشته باشیم. ( با استفاده از اوپراتور []).</p><p>هردو کلاس قبلی که گفته شد دارای یک نسخه غیر مرتب هم هستند که سربار کمتری داره و برای استفاده ازشون کافیه یه <span dir="ltr"><code class="language-plaintext highlighter-rouge">&lrm;unordered_</code></span>&rlm; پشت اسم کلاس بذاریم.</p><p><strong>نکاتی درباره Container Adapter ها:</strong></p><p>این کانتینر ها در اصل همون first class container ها هستند که عملیات هاشون محدود شده و از iterator پشتیبانی نمی‌کنن. بنابراین لایه زیرین کلاس های این کانتینر از کلاس های first class container ها تشکیل میشه.</p><ul><li>کلاس stack که یک استک رو میسازه، به صورت پیشفرض از deque استفاده می‌کنه.<li>کلاس queue که یک صف رو میسازه، به صورت پیشفرض از deque استفاده می‌کنه.<li>کلاس priority_qeueu که یک صف اولویت دار رو میسازه(صفی که مقادیر داخلش معمولا با استفاده از تکنیک heap، مرتب شده‌ند)، به صورت پیش‌فرض از کلاس vector به عنوان لایه زیرین خودش استفاده می‌کنه comparator function هم داره.</ul><h2 id="پیمایش-کننده-ها-iterators">پیمایش کننده ها (Iterators)</h2><p>ایتریتور ها چیزی شبیه به پوینتر ها هستند که قابلیت های بیشتری دارن و برای دسترسی و تغییر المان های یک کانتینر بکار میرن. مکانیسم دسترسی و پیمایش در یک کانتینر رو کپسوله میکنن و این به الگوریتم ها اجازه میده که بدون وابستگی به پیاده سازی لایه کانتینر، بتونن کار خودشون رو انجام بدن.</p><p>چند تابع داریم که میتونن برامون یک iterator برای یک کانتینر و یا حتی یک آرایه بسازن.</p><p>توابع <span dir="ltr"><code class="language-plaintext highlighter-rouge">&lrm;begin</code></span>&rlm; و <span dir="ltr"><code class="language-plaintext highlighter-rouge">&lrm;end</code></span>&rlm; که یک اشاره گر به اعضاء کانتینر میسازن( از سی++ ۱۱ به بعد میتونن یک پوینتر از built-in array ها بسازن حتی) و توابع <span dir="ltr"><code class="language-plaintext highlighter-rouge">&lrm;cbeing</code></span>&rlm; , <span dir="ltr"><code class="language-plaintext highlighter-rouge">&lrm;cend</code></span>&rlm; که یک ایتریتور const میسازن و <span dir="ltr"><code class="language-plaintext highlighter-rouge">&lrm;rbegin</code></span>&rlm; , <span dir="ltr"><code class="language-plaintext highlighter-rouge">&lrm;rend</code></span>&rlm; , <span dir="ltr"><code class="language-plaintext highlighter-rouge">&lrm;crbegin</code></span>&rlm; , <span dir="ltr"><code class="language-plaintext highlighter-rouge">&lrm;crend</code></span>&rlm; که قابلیت پیمایش برعکس روی یک آرایه رو میدن(از سی++ ۱۴ به بعد).</p><h2 id="الگوریتم-ها">الگوریتم ها</h2><p>الگوریتم ها شامل پیاده سازی ساختمان داده ها، الگوریتم های جستجو، مقایسه و مرتب سازی هستن که معمولا از ایتریتور ها استفاده میکنن. ایتریتور هایی که یه کانتینر ساپورت میکنه مشخص میکنه که آیا اون کانتینر میتونه از یه الگوریتم خاص استفاده بکنه یا نه. در مورد این بخش توی فصل بعدی کتاب به صورت مفصل بحث شده.</p><p>خب این فصل تقریبا طولانی هم تموم شد. هرچند مثل همیشه خیلی روش تمرکز نداشتم. اما تازگی دارم از تکنیک پومودورو استفاده می‌کنم و فعلا که جواب داده. فصل بعد هم درباره کتابخانه استاندارد صحبت می‌کنیم و بیشتر تمرکزمون روی بخش الگوریتم های این کتابخونه هست. بوس.</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/%D8%B3%DB%8C/'>سی++</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/adapter-container/" class="post-tag no-text-decoration" >adapter container</a> <a href="/tags/algorithm/" class="post-tag no-text-decoration" >algorithm</a> <a href="/tags/associative-container/" class="post-tag no-text-decoration" >associative container</a> <a href="/tags/c/" class="post-tag no-text-decoration" >C++</a> <a href="/tags/container/" class="post-tag no-text-decoration" >container</a> <a href="/tags/first-class-container/" class="post-tag no-text-decoration" >first class container</a> <a href="/tags/iterator/" class="post-tag no-text-decoration" >iterator</a> <a href="/tags/near-container/" class="post-tag no-text-decoration" >near container</a> <a href="/tags/stl/" class="post-tag no-text-decoration" >STL</a> <a href="/tags/%DA%A9%D8%AA%D8%A7%D8%A8%D8%AE%D8%A7%D9%86%D9%87/" class="post-tag no-text-decoration" >کتابخانه</a> <a href="/tags/%DA%A9%D8%AA%D8%A7%D8%A8%D8%AE%D8%A7%D9%86%D9%87-%D8%A7%D8%B3%D8%AA%D8%A7%D9%86%D8%AF%D8%A7%D8%B1%D8%AF/" class="post-tag no-text-decoration" >کتابخانه استاندارد</a> <a href="/tags/%D8%AF%D8%A7%DB%8C%D8%AA%D9%84/" class="post-tag no-text-decoration" >دایتل</a> <a href="/tags/%D8%B3%DB%8C/" class="post-tag no-text-decoration" >سی++</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> این پست تحت مجوز <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> منتشر شده است.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">اشتراک گذاری</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=نکات جدیدی که از فصل ۱۵ دایتل یاد گرفتم – کتابخانه استاندارد - سیدپولر&url=https://www.seedpuller.ir/posts/what-ive-learned-from-deitel-chapter-15/" data-toggle="tooltip" data-placement="top" title="توئیتر" target="_blank" rel="noopener" aria-label="توئیتر"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://telegram.me/share?text=نکات جدیدی که از فصل ۱۵ دایتل یاد گرفتم – کتابخانه استاندارد - سیدپولر&url=https://www.seedpuller.ir/posts/what-ive-learned-from-deitel-chapter-15/" data-toggle="tooltip" data-placement="top" title="تلگرام" target="_blank" rel="noopener" aria-label="تلگرام"> <i class="fa-fw fab fa-telegram"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="کپی لینک پست"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/concurrency-in-cpp-chapter1/">همزمانی در سی++: مفاهیم اولیه</a><li><a href="/posts/concurrency-in-cpp-chapter3-5/">همزمانی در سی++(۵): جایگزین های mutex</a><li><a href="/posts/concurrency-in-cpp-chapter3-3/">همزمانی در سی++(۳): Dead Lock ها</a><li><a href="/posts/concurrency-in-cpp-chapter3-4/">همزمانی در سی++(۴): ژانگولر بازی با mutex و کارهای دیگر</a><li><a href="/posts/concurrency-in-cpp-chapter3-1/">همزمانی در سی++: اشتراک گذاری داده ها(۱)</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/c/">C++</a> <a class="post-tag" href="/tags/%D8%B3%DB%8C/">سی++</a> <a class="post-tag" href="/tags/inner-struggle/">Inner Struggle</a> <a class="post-tag" href="/tags/%D8%AF%D8%A7%DB%8C%D8%AA%D9%84/">دایتل</a> <a class="post-tag" href="/tags/%DB%8C%D8%A7%D8%AF%DA%AF%DB%8C%D8%B1%DB%8C/">یادگیری</a> <a class="post-tag" href="/tags/concurrency-in-action/">concurrency in action</a> <a class="post-tag" href="/tags/concurrent-processing/">concurrent processing</a> <a class="post-tag" href="/tags/%D8%A8%D8%B1%D9%86%D8%A7%D9%85%D9%87-%D9%86%D9%88%DB%8C%D8%B3%DB%8C-%DA%86%D9%86%D8%AF-%D9%86%D8%AE%DB%8C/">برنامه نویسی چند نخی</a> <a class="post-tag" href="/tags/%D8%B3%DB%8C-%DB%B1%DB%B7/">سی++۱۷</a> <a class="post-tag" href="/tags/%D9%85%D9%88%D8%A7%D8%B2%DB%8C-%DA%A9%D8%A7%D8%B1%DB%8C/">موازی کاری</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/deitel-chapter16-stl-algorithms/"><div class="card-body"> <span class="timeago small" > Jul 22, 2020 <i class="unloaded">2020-07-22T00:00:00+04:30</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>فصل ۱۶ دایتل: الگوریتم های موجود در کتابخانه استاندارد</h3><div class="text-muted small"><p> در این فصل قراره که یاد بگیریم چطور با استفاده از iterator ها و algorithm(الگوریتم) های موجود در کتابخانه استاندارد سی++ یا همون STL کارهامون رو پیش ببریم. یاد میگیریم که توابع لاندا چی هستن و چط...</p></div></div></a></div><div class="card"> <a href="/posts/deitel-chapter21-strings/"><div class="card-body"> <span class="timeago small" > Aug 11, 2020 <i class="unloaded">2020-08-11T00:00:00+04:30</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>فصل ۲۱ دایتل: رشته ها</h3><div class="text-muted small"><p> توی این فصل در مبحث رشته ها در سی++ بیشتر عمیق میشیم. درواقع کلاس string از STL رو بررسی می‌کنیم. پست کوتاهیه چون بیشتر چیزها رو بلد بودم :) تابع compare این تابع جالبیه که باهاش میتونیم بخش خاص...</p></div></div></a></div><div class="card"> <a href="/posts/what-i-learned-from-deitel-chapter9/"><div class="card-body"> <span class="timeago small" > Mar 29, 2020 <i class="unloaded">2020-03-29T00:00:00+04:30</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>از فصل نهم کتاب برنامه نویسی سی++ دایتل چی یادگرفتم</h3><div class="text-muted small"><p> فصل نهم از کتاب C++ How To Program (نگارش ۲۰۱۷) رو تموم کردم و توی این پست نکاتی که از این فصل یادگرفتم(و یادم مونده=) ) رو می‌نویسم. تابع نابودگر (Destructor) علاوه بر ترتیب اجرا شدنش برای اشیاء...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/what-ive-learned-from-deitel-chapter14/" class="btn btn-outline-primary" prompt="قبلی"><p>نکات جدیدی که از فصل ۱۲ سی++ دایتل یاد گرفتم – چندریختی</p></a> <a href="/posts/deitel-chapter16-stl-algorithms/" class="btn btn-outline-primary" prompt="بعدی"><p>فصل ۱۶ دایتل: الگوریتم های موجود در کتابخانه استاندارد</p></a></div></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('.post-content img'); const observer = lozad(imgs); observer.observe(); </script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div><div class="footer-right" style="direction: rtl; text-align: right;"><p class="mb-0"> <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">مطالب این وبسایت تحت مجوز CC-BY-4.0 منتشر می‌شوند</span></p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/c/">C++</a> <a class="post-tag" href="/tags/%D8%B3%DB%8C/">سی++</a> <a class="post-tag" href="/tags/inner-struggle/">Inner Struggle</a> <a class="post-tag" href="/tags/%D8%AF%D8%A7%DB%8C%D8%AA%D9%84/">دایتل</a> <a class="post-tag" href="/tags/%DB%8C%D8%A7%D8%AF%DA%AF%DB%8C%D8%B1%DB%8C/">یادگیری</a> <a class="post-tag" href="/tags/concurrency-in-action/">concurrency in action</a> <a class="post-tag" href="/tags/concurrent-processing/">concurrent processing</a> <a class="post-tag" href="/tags/%D8%A8%D8%B1%D9%86%D8%A7%D9%85%D9%87-%D9%86%D9%88%DB%8C%D8%B3%DB%8C-%DA%86%D9%86%D8%AF-%D9%86%D8%AE%DB%8C/">برنامه نویسی چند نخی</a> <a class="post-tag" href="/tags/%D8%B3%DB%8C-%DB%B1%DB%B7/">سی++۱۷</a> <a class="post-tag" href="/tags/%D9%85%D9%88%D8%A7%D8%B2%DB%8C-%DA%A9%D8%A7%D8%B1%DB%8C/">موازی کاری</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://www.seedpuller.ir{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
