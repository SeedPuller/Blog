<!DOCTYPE html><html lang="fa-IR" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="pv-cache-enabled" content="false"><meta name="generator" content="Jekyll v4.2.0" /><meta property="og:title" content="همزمانی در سی++(۵): جایگزین های mutex" /><meta name="author" content="سیدپولر" /><meta property="og:locale" content="fa_IR" /><meta name="description" content="در پست قبل درباره اینکه چه کار های دیگه‌ای میشه با mutex ها انجام داد صحبت کردیم و همچنین کلاس std::unique_ptr رو معرفی کردیم که دست ما رو برای استفاده از mutex ها باز می‌کنه. در این پست قراره که جایگزین های میوتکس ها رو بررسی کنیم و سناریو هایی رو ببینیم که برای پیاده سازیشون نیازی به استفاده از میوتکس نیست." /><meta property="og:description" content="در پست قبل درباره اینکه چه کار های دیگه‌ای میشه با mutex ها انجام داد صحبت کردیم و همچنین کلاس std::unique_ptr رو معرفی کردیم که دست ما رو برای استفاده از mutex ها باز می‌کنه. در این پست قراره که جایگزین های میوتکس ها رو بررسی کنیم و سناریو هایی رو ببینیم که برای پیاده سازیشون نیازی به استفاده از میوتکس نیست." /><link rel="canonical" href="https://www.seedpuller.ir/posts/concurrency-in-cpp-chapter3-5/" /><meta property="og:url" content="https://www.seedpuller.ir/posts/concurrency-in-cpp-chapter3-5/" /><meta property="og:site_name" content="سیدپولر" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2021-04-18T00:00:00+04:30" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="همزمانی در سی++(۵): جایگزین های mutex" /><meta name="twitter:site" content="@twitter_username" /><meta name="twitter:creator" content="@سیدپولر" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"author":{"@type":"Person","name":"سیدپولر"},"description":"در پست قبل درباره اینکه چه کار های دیگه‌ای میشه با mutex ها انجام داد صحبت کردیم و همچنین کلاس std::unique_ptr رو معرفی کردیم که دست ما رو برای استفاده از mutex ها باز می‌کنه. در این پست قراره که جایگزین های میوتکس ها رو بررسی کنیم و سناریو هایی رو ببینیم که برای پیاده سازیشون نیازی به استفاده از میوتکس نیست.","url":"https://www.seedpuller.ir/posts/concurrency-in-cpp-chapter3-5/","@type":"BlogPosting","headline":"همزمانی در سی++(۵): جایگزین های mutex","dateModified":"2021-04-18T22:57:32+04:30","datePublished":"2021-04-18T00:00:00+04:30","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.seedpuller.ir/posts/concurrency-in-cpp-chapter3-5/"},"@context":"https://schema.org"}</script><title>همزمانی در سی++(۵): جایگزین های mutex | سیدپولر</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id="></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', ''); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="https://avatars.githubusercontent.com/u/24620298?s=460&u=dd6165c7d8103164b24d6f40a169594a2c8dac42&v=4" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">سیدپولر</a></div><div class="site-subtitle font-italic">نوشته های مور دانه‌کش</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/SeedPuller" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['SeedPuller','gmail.com'].join('@')" aria-label="email" class="order-4" > <i class="fas fa-envelope"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Posts </a> </span> <span>همزمانی در سی++(۵): جایگزین های mutex</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8" style="direction: rtl; text-align: right;"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip style="direction: rtl; text-align: right;">همزمانی در سی++(۵): جایگزین های mutex</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Sun, Apr 18, 2021, 12:00 AM +0430" > Apr 18, 2021 <i class="unloaded">2021-04-18T00:00:00+04:30</i> </span> توسط <span class="author"> سیدپولر </span></div><div> <span> بروز شده در <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Sun, Apr 18, 2021, 10:57 PM +0430" > Apr 18, 2021 <i class="unloaded">2021-04-18T22:57:32+04:30</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="حاوی 1447 کلمه"> 8 دقیقه</span></div></div><div class="post-content"><p>در پست قبل درباره اینکه چه کار های دیگه‌ای میشه با mutex ها انجام داد صحبت کردیم و همچنین کلاس <span dir="ltr"><code class="language-plaintext highlighter-rouge">&lrm;std::unique_ptr</code></span>&rlm; رو معرفی کردیم که دست ما رو برای استفاده از mutex ها باز می‌کنه. در این پست قراره که جایگزین های میوتکس ها رو بررسی کنیم و سناریو هایی رو ببینیم که برای پیاده سازیشون نیازی به استفاده از میوتکس نیست.</p><p>با اینکه میوتکس ها یکی از پر کاربرد ترین مکانیزم ها برای محافظت از داده ها هستن ولی تنها گزینه نیستن. جایگزین های بسیاری برای این منظور وجود دارن که در بعضی از شرایط کاملا انتخاب معقول‌تری به نسبت میوتکس ها هستند.</p><h2 id="محافظت-از-داده-اشتراکی-فقط-در-زمان-ساخته-شدن">محافظت از داده اشتراکی فقط در زمان ساخته شدن</h2><p>بعضی وقت ها هست که تنها Modification ای که روی داده ما صورت می‌گیره، همون موقع ساختنشه! مثلا اگر که داده ساخته و Initialize شد عملا تبدیل به یک داده read-only یا همون «فقط خواندنی می‌شه» و همونطور که می‌دونیم، داده ای که فقط برای خوندن مورد استفاده قرار می‌گیره نیاز به حفاظت نداره!</p><p>قبل از اینکه این بحث رو ادامه بدم نیازمند این هستیم که با مفهوم Lazy Initialization آشنا باشیم.</p><h3 id="مقدار-دهی-اولیه-با-تاخیر-یا-lazy-initialization">مقدار دهی اولیه با تاخیر یا Lazy Initialization</h3><p>فرض کنید یک منبع(Resource) ای داریم که ساختن و مقدار دهی اولیه‌ش کاری‌ست بس سنگین! (مثلا نیازمند تخصیص مقدار زیادی حافظه) انقدری که بهتره فقط زمانی که میخوایم از ریسورس استفاده بکنیم بیایم و بسازیمش/مقداردهی‌ش کنیم. به این می‌گن <strong>Lazy Initialization</strong></p><p>توی برنامه های تک تردی این کار ساده‌ست؛ فقط کافیه قبل از استفاده از اون داده چک کنیم که آیا هنوز مقدار دهی شده یا نه. چیزی شبیه به کد زیر:</p><div class="language-cpp highlighter-rouge"><div class="highlight" style="direction: ltr; text-align: left;"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">some_resource</span><span class="o">&gt;</span> <span class="n">resource_ptr</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">foo</span><span class="p">()</span>
<span class="p">{</span>
	<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">resource_ptr</span><span class="p">){</span>
		<span class="n">resource_ptr</span><span class="p">.</span><span class="n">reset</span><span class="p">(</span><span class="k">new</span> <span class="n">some_resource</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">resource_ptr</span><span class="o">-&gt;</span><span class="n">do_something</span><span class="p">();</span>
<span class="p">}</span>

</pre></table></code></span>&rlm;</div></div><p>حالا اگر بخوایم همینکار رو با یک کد چند-نخی(multi thread) بکنیم چطوری میشه؟‌ اولین چیزی که به ذهن میرسه اینه که «خب میایم و با استفاده از Mutex داده رو محافظت می‌کنیم و چک می‌کنیم که آیا مقداردهی شده یا نه.». چیزی شبیه به این کد:</p><div class="language-cpp highlighter-rouge"><div class="highlight" style="direction: ltr; text-align: left;"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">some_resource</span><span class="o">&gt;</span> <span class="n">resource_ptr</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">resource_mutex</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">foo</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lk</span><span class="p">(</span><span class="n">resource_mutex</span><span class="p">);</span> <span class="c1">// checkpoint 1</span>
	<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">resource_ptr</span><span class="p">){</span>
		<span class="n">resource_ptr</span><span class="p">.</span><span class="n">reset</span><span class="p">(</span><span class="k">new</span> <span class="n">some_resource</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">lk</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
	<span class="n">resource_ptr</span><span class="o">-&gt;</span><span class="n">do_something</span><span class="p">();</span>
<span class="p">}</span>
</pre></table></code></span>&rlm;</div></div><p>اما این کد مشکلی داره! اونم اینکه همه ترد ها باید در checkpoint شماره ۱ منتظر بمونن تا قفل آزاد بشه تا اونا هم بتونن قفل کنن و ببینن که آیا داده مقدار دهی شده یا نه! و فقط هم یکی از این ترد ها (اولی‌شون) هست که میره و داده رو مقداردهی می‌کنه. بقیه فقط الکی چک می‌کنن. پس یه چیزی درست نیست… بقیه ترد ها اینجا گیر می‌کنن و به نوعی یک bottle-neck ایجاد شده. راه حل چیه؟</p><p>اول باید ببینیم دقیقا چی می‌خوایم. چیزی که ما میخوایم اینه: فقط یکبار مقداردهی صورت بگیره و دفعات بعد فقط از اون داده استفاده بشه.</p><h3 id="استفاده-از-stdcall_once">استفاده از <span dir="ltr"><code class="language-plaintext highlighter-rouge">&lrm;std::call_once</code></span>&rlm;</h3><p>دوستان خوب ما در کمیته استاندارد سی++ اومدن و چیزی رو تحت عنوان <span dir="ltr"><code class="language-plaintext highlighter-rouge">&lrm;std::once_flag</code></span>&rlm; و <span dir="ltr"><code class="language-plaintext highlighter-rouge">&lrm;std::call_once</code></span>&rlm; پیاده سازی کردن. با استفاده از این دو کلاس می‌تونیم دقیقا اون چیزی که میخواستیم رو پیاده سازی بکنیم. کد بالا به این شکل تبدیل می‌شه:</p><div class="language-cpp highlighter-rouge"><div class="highlight" style="direction: ltr; text-align: left;"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">some_resource</span><span class="o">&gt;</span> <span class="n">resource_ptr</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">once_flag</span> <span class="n">resource_flag</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">init_resource</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">resource_ptr</span><span class="p">.</span><span class="n">reset</span><span class="p">(</span><span class="k">new</span> <span class="n">some_resource</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">foo</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">std</span><span class="o">::</span><span class="n">call_once</span><span class="p">(</span><span class="n">resource_flag</span><span class="p">,</span><span class="n">init_resource</span><span class="p">);</span>
	<span class="n">resource_ptr</span><span class="o">-&gt;</span><span class="n">do_something</span><span class="p">();</span>
<span class="p">}</span>

</pre></table></code></span>&rlm;</div></div><p>تابع <span dir="ltr"><code class="language-plaintext highlighter-rouge">&lrm;std::call_once</code></span>&rlm; این اطمینان رو میده که فقط و فقط یکبار تابع مورد نظر ما رو اجرا بکنه.(و اینکار رو با کمک <span dir="ltr"><code class="language-plaintext highlighter-rouge">&lrm;std::once_flag</code></span>&rlm; انجام می‌ده). درواقع اون flag کمک به فهم این موضوع می‌کنه که آیا تابع هدف ما قبلا اجرا شده یا نه.</p><p>به این ترتیب به راحتی ترد های مختلف می‌تونن با خیال راحت از داده‌شون استفاده بکنن.</p><blockquote><p>استفاده از <span dir="ltr"><code class="language-plaintext highlighter-rouge">&lrm;std:call_once</code></span>&rlm; سریعتر و بهینه تر از mutex هاست.</p></blockquote><h3 id="استفاده-از-static">استفاده از <span dir="ltr"><code class="language-plaintext highlighter-rouge">&lrm;static</code></span>&rlm;</h3><p>بله! تا قبل از سی++۱۱ استفاده از متغییر های <span dir="ltr"><code class="language-plaintext highlighter-rouge">&lrm;static</code></span>&rlm; برای خودش معضلی بود(چون مثلا ترد ها سعی می‌کردن باهمدیگه یک متغییر رو مقداردهی کنن) اما بعد از سی++ ۱۱ این مشکل برطرف شد. حالا وقتی یک متغییر <span dir="ltr"><code class="language-plaintext highlighter-rouge">&lrm;static</code></span>&rlm; داریم میتونیم مطمئن باشیم که فقط یکی از ترد ها عمل مقداردهی رو انجام می‌ده و بقیه اینکار رو نمی‌کنن. شبیه به مکانیزم <span dir="ltr"><code class="language-plaintext highlighter-rouge">&lrm;std::call_once</code></span>&rlm; (:</p><div class="language-cpp highlighter-rouge"><div class="highlight" style="direction: ltr; text-align: left;"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">my_class</span><span class="p">;</span>
<span class="n">my_class</span><span class="o">&amp;</span> <span class="n">get_my_class_instance</span><span class="p">()</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="n">my_class</span> <span class="n">instance</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">instance</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></span>&rlm;</div></div><p>در این کد، هر چندتا ترد هم که تابع <span dir="ltr"><code class="language-plaintext highlighter-rouge">&lrm;get_my_class_instance()‍</code></span>&rlm; رو فراخوانی بکنن، از <span dir="ltr"><code class="language-plaintext highlighter-rouge">&lrm;instance</code></span>&rlm; فقط یکبار ساخته میشه(اولین تردی که بتونه این تابع رو فراخوانی بکنه، میسازتش). به همین زیبایی (:</p><p>محافظت از داده ها «فقط برای زمان ساخته شدن» یک مثال کوچیکی بود از یک مفهوم کلی تر: <strong>ساختمان داده هایی که نسبت تعداد خوانده شدنشون خیلی بیشتر از نوشته شدنشونه</strong></p><p>یعنی چی؟ یعنی ساختمان داده ای داریم که در اکثر موارد فقط ازش برای خوندن استفاده می‌شه و خیلی کمتر پیش میاد که نیاز باشه این ساختمان داده رو آپدیت بکنیم. مثالی که کتاب زده خیلی خوبه: DNS! بله دقیقا DNS یا فارسی‌ش که می‌شه «ساناد» (مخفف <strong>سا</strong>مانه <strong>نا</strong>م <strong>د</strong>امنه) مثال عملی همین توضیح است. ساناد ها خیلی کم آپدیت می‌شن و بیشتر اوقات فقط خونده میشن. و همونطور هم که می‌دونیم، «اشکالی نداره که چندتا ترد همزمان از یک منبع چیزی رو بخونن».</p><h2 id="محافظت-از-ساختمان-داده-های-به-ندرت-بهروز-شونده">محافظت از ساختمان داده های به ندرت به‌روز شونده</h2><p>همونطور که دیدیم، چیز هایی مثل ساناد وجود دارن که بیشتر از نوشتن، عمل خوندن روشون صورت می‌گیره. اما بهرحال این به‌روز رسانی ها هرچقدر هم کم باشن، بالاخره اتفاق می‌افتن و باید داده رو در این زمان محافظت کرد.</p><p>یک راه حل اینه که ساختمان داده‌مون رو طوری طراحی کنیم که ذاتا در مقابل همچین چیزی مقاوم باشه. یعنی به شکل ذاتی قابلیت این رو داشته باشه که عملیات های خوندن و نوشتن به شکل همزمان روش انجام بشه و آخ نگه. اما این داستان مربوط میشه به فصل ۶ و ۷ کتاب و خب ما هنوز تازه فصل ۳ ایم ((((:</p><p>راه بعدی اینه که بیایم یک دسترسی اختصاصی برای آپدیت کردن ساختمان‌مون ایجاد بکنیم. دقیقا همون کاری که میوتکس ها انجام می‌دادن. یک دسترسی mutual exclusive ایجاد می‌کردن. اما خب… اگر قرار باشه از میوتکس برای محافظت استفاده بکنیم، عملا همش برای خوندن داده ها هم ترد ها باید منتظر بمونن که این قفل لعنتی آزاد بشه دیگه نه؟ آره. درسته.</p><p>برای همینه که ما به یک نوع جدیدی از mutex ها نیاز داریم! بله! دیگر زمان بدبختی به پایان رسید! نیازمند پیشرفت و بیرون آمدن از انزوا هستیم! ای ملت! بشتابید! به حرف های این عقب افتاده ها که استفاده از میوتکس کورشان کرده و از تعصب آن شقیقه هایشان داغ شده گوش ندهید! دوران تاریکی به سر آمد! فقط کافی‌ست ۱ عدد بیتکوین به حساب بنده واریز نمائید تا همه این مشکلات را برای شما حل بنمایم و همچنین باهم به بستنی فروشی می‌رویم و در اسرع وقت یک تونل از خوابگاه پسران به دختران حفر خواهم کرد. رای فراموش نشه!</p><p>به این نوع جدید از mutex ها اصطلاحا می‌گن میوتکس های <em>reader-writer</em>. چرا؟‌ بخاطر اینکه دو جور دسترسی ایجاد می‌کنن:</p><ol><li>یک دسترسی اختصاصی برای نوشتن توسط «فقط یک ترد»<li>چند دسترسی همزمان برای خواندن توسط «چندین ترد»</ol><p>در سی++ ۱۷ گرامی ما کلاسی هست به اسم <span dir="ltr"><code class="language-plaintext highlighter-rouge">&lrm;std::shared_mutex</code></span>&rlm; که برای همین منظور ساخته شده. البته به نظر در فصل ۸ متوجه می‌شیم که این میوتکس ها تنها و بهترین راه نیستن و انتخاب این راه منوط به خیلی چیز ها از جمله نسبت خواندن/نوشتن هست.</p><p>برای قفل کردن این نوع میوتکس ها به شکل <strong>اختصاصی</strong> میتونیم از کلاس های قبلی مثل <span dir="ltr"><code class="language-plaintext highlighter-rouge">&lrm;std::scopred_lock</code></span>&rlm; یا <span dir="ltr"><code class="language-plaintext highlighter-rouge">&lrm;std::lock_guard</code></span>&rlm; استفاده کنیم. اما برای قفل کردن به شکل <strong>مشترک</strong> نیازمند این هستیم که از <span dir="ltr"><code class="language-plaintext highlighter-rouge">&lrm;std::shared_lock</code></span>&rlm; استفاده بکنیم. فرق اینها چیست؟ خب <span dir="ltr"><code class="language-plaintext highlighter-rouge">&lrm;std::shared_lock</code></span>&rlm; که از لحاظ اینترفیس کاملا شبیه به <span dir="ltr"><code class="language-plaintext highlighter-rouge">&lrm;std::unique_lock</code></span>&rlm; هست. چندین ترد می‌تونن یک <span dir="ltr"><code class="language-plaintext highlighter-rouge">&lrm;std::shared_mutex</code></span>&rlm; رو باهمدیگه در اختیار داشته باشن و به شکل مشترک قفل کنن. در این وضعیت، اگر تردی بخواد به شکل اختصاصی قفل رو انجام بده باید صبر کنه که همهٔ ترد های دیگه، قفل مشترک‌شون رو باز کنن. و وقتی که دسترسی اختصاصی توسط <span dir="ltr"><code class="language-plaintext highlighter-rouge">&lrm;std::scoped_lock</code></span>&rlm; یا امثالهم ایجاد شد، دیگه هیچ ترد دیگه ای نمیتونه چه دسترسی مشترک و چه دسترسی اختصاصی ایجاد بکنه و باید تا زمان آزاد شدن <span dir="ltr"><code class="language-plaintext highlighter-rouge">&lrm;std::shared_mutex</code></span>&rlm; صبر کنه.</p><p>کتاب مثال خوبی زده که اینجا هم میارم:</p><div class="language-cpp highlighter-rouge"><div class="highlight" style="direction: ltr; text-align: left;"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre><span class="cp">#include &lt;map&gt;
#include &lt;string&gt;
#include &lt;mutex&gt;
#include &lt;shared_mutex&gt;
</span><span class="k">class</span> <span class="nc">dns_entry</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">dns_cache</span>
<span class="p">{</span>
<span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span><span class="n">dns_entry</span><span class="o">&gt;</span> <span class="n">entries</span><span class="p">;</span>
<span class="k">mutable</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_mutex</span> <span class="n">entry_mutex</span><span class="p">;</span>
<span class="nl">public:</span>
	<span class="n">dns_entry</span> <span class="n">find_entry</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">domain</span><span class="p">)</span> <span class="k">const</span>
	<span class="p">{</span>
		<span class="n">std</span><span class="o">::</span><span class="n">shared_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">shared_mutex</span><span class="o">&gt;</span> <span class="n">lk</span><span class="p">(</span><span class="n">entry_mutex</span><span class="p">);</span>
		<span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span><span class="n">dns_entry</span><span class="o">&gt;::</span><span class="n">const_iterator</span> <span class="k">const</span> <span class="n">it</span><span class="o">=</span>
		<span class="n">entries</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">domain</span><span class="p">);</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">it</span><span class="o">==</span><span class="n">entries</span><span class="p">.</span><span class="n">end</span><span class="p">())</span><span class="o">?</span><span class="n">dns_entry</span><span class="p">()</span><span class="o">:</span><span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="kt">void</span> <span class="n">update_or_add_entry</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">domain</span><span class="p">,</span> <span class="n">dns_entry</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">dns_details</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">shared_mutex</span><span class="o">&gt;</span><span class="n">entries</span><span class="p">[</span><span class="n">domain</span><span class="p">]</span><span class="o">=</span><span class="n">dns_details</span><span class="p">;</span>
		<span class="n">lk</span><span class="p">(</span><span class="n">entry_mutex</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">};</span>
</pre></table></code></span>&rlm;</div></div><h2 id="پایان">پایان</h2><p>خب فصل ۳ کتاب C++ Concurrency in Action هم تموم شد. خیلی خیلی کُند پیش می‌رم. نمیدونم فرصت می‌کنم تا آخر عمرم این کتاب رو تموم کنم یا نه… بهرحال، فصل بعدی درباره «همگام سازی عملیات های همزمان» هست. عزت زیاد (:</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/%D8%B3%DB%8C/'>سی++</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/c/" class="post-tag no-text-decoration" >C++</a> <a href="/tags/concurrency-in-action/" class="post-tag no-text-decoration" >concurrency in action</a> <a href="/tags/concurrent-processing/" class="post-tag no-text-decoration" >concurrent processing</a> <a href="/tags/%D9%85%D9%88%D8%A7%D8%B2%DB%8C-%DA%A9%D8%A7%D8%B1%DB%8C/" class="post-tag no-text-decoration" >موازی کاری</a> <a href="/tags/%D9%87%D9%85%D8%B2%D9%85%D8%A7%D9%86%DB%8C/" class="post-tag no-text-decoration" >همزمانی</a> <a href="/tags/%D8%B3%DB%8C/" class="post-tag no-text-decoration" >سی++</a> <a href="/tags/%D8%B3%DB%8C-%DB%B1%DB%B7/" class="post-tag no-text-decoration" >سی++۱۷</a> <a href="/tags/shared-data/" class="post-tag no-text-decoration" >shared data</a> <a href="/tags/mutex/" class="post-tag no-text-decoration" >mutex</a> <a href="/tags/std-mutex/" class="post-tag no-text-decoration" >std::mutex</a> <a href="/tags/%D9%85%DB%8C%D9%88%D8%AA%DA%A9%D8%B3/" class="post-tag no-text-decoration" >میوتکس</a> <a href="/tags/dead-lock/" class="post-tag no-text-decoration" >Dead Lock</a> <a href="/tags/%D8%AF%D8%AF%D9%84%D8%A7%DA%A9/" class="post-tag no-text-decoration" >ددلاک</a> <a href="/tags/std-lock/" class="post-tag no-text-decoration" >std::lock</a> <a href="/tags/std-scoped-lock/" class="post-tag no-text-decoration" >std::scoped_lock</a> <a href="/tags/thread/" class="post-tag no-text-decoration" >thread</a> <a href="/tags/multithread/" class="post-tag no-text-decoration" >multithread</a> <a href="/tags/multi-thread/" class="post-tag no-text-decoration" >multi thread</a> <a href="/tags/multi-threading/" class="post-tag no-text-decoration" >multi threading</a> <a href="/tags/std-unique-lock/" class="post-tag no-text-decoration" >std::unique_lock</a> <a href="/tags/%DA%86%D9%86%D8%AF-%D9%86%D8%AE%DB%8C/" class="post-tag no-text-decoration" >چند نخی</a> <a href="/tags/%D8%A8%D8%B1%D9%86%D8%A7%D9%85%D9%87-%D9%86%D9%88%DB%8C%D8%B3%DB%8C-%DA%86%D9%86%D8%AF-%D9%86%D8%AE%DB%8C/" class="post-tag no-text-decoration" >برنامه نویسی چند نخی</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> این پست تحت مجوز <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> منتشر شده است.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">اشتراک گذاری</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=همزمانی در سی++(۵): جایگزین های mutex - سیدپولر&url=https://www.seedpuller.ir/posts/concurrency-in-cpp-chapter3-5/" data-toggle="tooltip" data-placement="top" title="توئیتر" target="_blank" rel="noopener" aria-label="توئیتر"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://telegram.me/share?text=همزمانی در سی++(۵): جایگزین های mutex - سیدپولر&url=https://www.seedpuller.ir/posts/concurrency-in-cpp-chapter3-5/" data-toggle="tooltip" data-placement="top" title="تلگرام" target="_blank" rel="noopener" aria-label="تلگرام"> <i class="fa-fw fab fa-telegram"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="کپی لینک پست"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/concurrency-in-cpp-chapter1/">همزمانی در سی++: مفاهیم اولیه</a><li><a href="/posts/concurrency-in-cpp-chapter3-5/">همزمانی در سی++(۵): جایگزین های mutex</a><li><a href="/posts/concurrency-in-cpp-chapter3-3/">همزمانی در سی++(۳): Dead Lock ها</a><li><a href="/posts/concurrency-in-cpp-chapter3-4/">همزمانی در سی++(۴): ژانگولر بازی با mutex و کارهای دیگر</a><li><a href="/posts/concurrency-in-cpp-chapter3-1/">همزمانی در سی++: اشتراک گذاری داده ها(۱)</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/c/">C++</a> <a class="post-tag" href="/tags/%D8%B3%DB%8C/">سی++</a> <a class="post-tag" href="/tags/inner-struggle/">Inner Struggle</a> <a class="post-tag" href="/tags/%D8%AF%D8%A7%DB%8C%D8%AA%D9%84/">دایتل</a> <a class="post-tag" href="/tags/%DB%8C%D8%A7%D8%AF%DA%AF%DB%8C%D8%B1%DB%8C/">یادگیری</a> <a class="post-tag" href="/tags/concurrency-in-action/">concurrency in action</a> <a class="post-tag" href="/tags/concurrent-processing/">concurrent processing</a> <a class="post-tag" href="/tags/%D8%A8%D8%B1%D9%86%D8%A7%D9%85%D9%87-%D9%86%D9%88%DB%8C%D8%B3%DB%8C-%DA%86%D9%86%D8%AF-%D9%86%D8%AE%DB%8C/">برنامه نویسی چند نخی</a> <a class="post-tag" href="/tags/%D8%B3%DB%8C-%DB%B1%DB%B7/">سی++۱۷</a> <a class="post-tag" href="/tags/%D9%85%D9%88%D8%A7%D8%B2%DB%8C-%DA%A9%D8%A7%D8%B1%DB%8C/">موازی کاری</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/concurrency-in-cpp-chapter1/"><div class="card-body"> <span class="timeago small" > Sep 24, 2020 <i class="unloaded">2020-09-24T00:00:00+03:30</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>همزمانی در سی++: مفاهیم اولیه</h3><div class="text-muted small"><p> بالاخره شروع کردم به خوندن کتاب C++ Concurrency in action نوشته Anthony Williams. این کتاب رو باید یک ماه پیش تموم می‌کردم اما مثل همیشه خیلی کند پیش رفتم و فقط ۲ فصلش رو تا الآن خوندم و تازه دارم...</p></div></div></a></div><div class="card"> <a href="/posts/concurrency-in-cpp-chapter3-4/"><div class="card-body"> <span class="timeago small" > Apr 12, 2021 <i class="unloaded">2021-04-12T00:00:00+04:30</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>همزمانی در سی++(۴): ژانگولر بازی با mutex و کارهای دیگر</h3><div class="text-muted small"><p> در این پست درباره اینکه چطور می‌تونیم یک سری ژانگولر بازی با mutex ها دربیاریم صحبت می‌کنیم. مثلا چطور میوتکس ها رو بین scope ها جابجا کنیم، یا چطور با انعطاف بیشتری نسبت به قفل کردن mutex ها اقدام...</p></div></div></a></div><div class="card"> <a href="/posts/concurrency-in-cpp-chapter3-3/"><div class="card-body"> <span class="timeago small" > Apr 8, 2021 <i class="unloaded">2021-04-08T00:00:00+04:30</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>همزمانی در سی++(۳): Dead Lock ها</h3><div class="text-muted small"><p> خب در پست قبل این مسئله که ترد ها برای استفاده از داده باهم مسابقه می‌دن رو کمی بررسی کردیم و یک راه حل دم دست هم براش پیشنهاد دادیم. توی این پست میخوایم در مورد مشکلی بحث کنیم که یجورایی برعکس Rac...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/concurrency-in-cpp-chapter3-4/" class="btn btn-outline-primary" prompt="قبلی"><p>همزمانی در سی++(۴): ژانگولر بازی با mutex و کارهای دیگر</p></a> <a href="/posts/Inner-Struggle5/" class="btn btn-outline-primary" prompt="بعدی"><p>یادداشت بداهه۵</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div><div class="footer-right" style="direction: rtl; text-align: right;"><p class="mb-0"> <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">مطالب این وبسایت تحت مجوز CC-BY-4.0 منتشر می‌شوند</span></p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/c/">C++</a> <a class="post-tag" href="/tags/%D8%B3%DB%8C/">سی++</a> <a class="post-tag" href="/tags/inner-struggle/">Inner Struggle</a> <a class="post-tag" href="/tags/%D8%AF%D8%A7%DB%8C%D8%AA%D9%84/">دایتل</a> <a class="post-tag" href="/tags/%DB%8C%D8%A7%D8%AF%DA%AF%DB%8C%D8%B1%DB%8C/">یادگیری</a> <a class="post-tag" href="/tags/concurrency-in-action/">concurrency in action</a> <a class="post-tag" href="/tags/concurrent-processing/">concurrent processing</a> <a class="post-tag" href="/tags/%D8%A8%D8%B1%D9%86%D8%A7%D9%85%D9%87-%D9%86%D9%88%DB%8C%D8%B3%DB%8C-%DA%86%D9%86%D8%AF-%D9%86%D8%AE%DB%8C/">برنامه نویسی چند نخی</a> <a class="post-tag" href="/tags/%D8%B3%DB%8C-%DB%B1%DB%B7/">سی++۱۷</a> <a class="post-tag" href="/tags/%D9%85%D9%88%D8%A7%D8%B2%DB%8C-%DA%A9%D8%A7%D8%B1%DB%8C/">موازی کاری</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://www.seedpuller.ir{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
